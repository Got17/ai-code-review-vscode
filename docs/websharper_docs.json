[
  {
    "filename": "websharper_aspnet.md",
    "sections": [
      {
        "heading": "Using WebSharper with ASP.NET",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/aspnet](https://developers.websharper.com/docs/v4.x/fs/aspnet)\n\nWebSharper is self-sufficient and can run as the single component of a web application, but it can also be integrated into an existing ASP.NET application. This integration is twofold:\n\n- Client-side WebSharper controls can be used within an ASPX page. This allows you to use C#/F#-compiled-to-JavaScript directly within an existing page, and take advantage of client-side reactive markup with WebSharper UI and easy remote calls.\n- Full WebSharper [sitelets](https://developers.websharper.com/docs/v4.x/fs/sitelets) can run alongside an ASP.NET application, sharing the same URL space, as well as the same server state, sessions, etc.\n\n---"
      },
      {
        "heading": "Required References",
        "content": "You need to add the following references to your ASP.NET web project:\n\n- Your WebSharper project\n- [WebSharper.CSharp NuGet package](http://www.nuget.org/packages/WebSharper.CSharp/)\n- [FSharp.Core NuGet package](http://www.nuget.org/packages/FSharp.Core/)\n\nFor FSharp.Core 4.3.x, add the following binding redirection to your `Web.config`:\n\n```xml\n<configuration>\n  <runtime>\n    <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n      <dependentAssembly>\n        <assemblyIdentity name=\"FSharp.Core\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n        <!-- FSharp.Core's 4.3.x NuGet package contains the 4.4.3.0 assembly -->\n        <bindingRedirect oldVersion=\"0.0.0.0-4.4.3.0\" newVersion=\"4.4.3.0\" />\n      </dependentAssembly>\n    </assemblyBinding>\n  </runtime>\n</configuration>\n```\n\n---"
      },
      {
        "heading": "Integrating Client-Side Controls in ASP.NET Pages",
        "content": "### C# Example\n\n```csharp\npublic static class Server\n{\n    [Remote]\n    public static Task<int[]> GetData()\n    {\n        return Task.FromResult(new[] { 1, 2, 3 });\n    }\n}\n\n[Serializable]\npublic class SimpleClientServerControl : WebSharper.Web.Control\n{\n    [JavaScript]\n    public override IControlBody Body\n    {\n        get\n        {\n            var model = new ListModel<int, int>(x => x);\n            Task.Run(async () =>\n            {\n                var data = await Server.GetData();\n                model.AppendMany(data);\n            });\n            return ul(model.View.DocSeqCached((int x) => li(\"Value= \", x)));\n        }\n    }\n}\n```\n\n### F# Example\n\n```fsharp\nnamespace WebSharperProject\n\nopen WebSharper\nopen WebSharper.UI\n\nmodule Server =\n    [<Rpc>]\n    let GetData () =\n        async { return [1; 2; 3] }\n\ntype SimpleClientServerControl() =\n    inherit Web.Control()\n\n    [<JavaScript>]\n    override this.Body =\n        let model = ListModel.FromSeq []\n        async {\n            let! data = Server.GetData()\n            model.AppendMany(data)\n        }\n        |> Async.Start\n        ul [] [\n            model.Doc(fun i -> li [] [text (\"Value = \" + string i)])\n        ] :> _\n```\n\n---"
      },
      {
        "heading": "Integration Steps in ASPX Page",
        "content": "### 1. Register controls in `Web.config`:\n\n```xml\n<configuration>\n  <system.web>\n    <pages>\n      <controls>\n        <add tagPrefix=\"WebSharper\" namespace=\"WebSharper.Web\" assembly=\"WebSharper.Web\"/>\n        <add tagPrefix=\"ws\" namespace=\"WebSharperProject\" assembly=\"WebSharperProject\"/>\n      </controls>\n    </pages>\n  </system.web>\n</configuration>\n```\n\n### 2. Add WebSharper ScriptManager to `<head>`:\n\n```aspx\n<head runat=\"server\">\n  <WebSharper:ScriptManager runat=\"server\" />\n</head>\n```\n\n### 3. Insert the control in the ASPX page body:\n\n```aspx\n<ws:SimpleClientServerControl runat=\"server\" />\n```\n\n---"
      },
      {
        "heading": "Enabling Remoting",
        "content": "### IIS 7.x+:\n\n```xml\n<configuration>\n  <system.webServer>\n    <modules>\n      <add name=\"WebSharper.RemotingModule\"\n           type=\"WebSharper.Web.RpcModule, WebSharper.Web\"/>\n    </modules>\n  </system.webServer>\n</configuration>\n```\n\n### IIS 6.x:\n\n```xml\n<configuration>\n  <system.web>\n    <httpModules>\n      <add name=\"WebSharper.RemotingModule\"\n           type=\"WebSharper.Web.RpcModule, WebSharper.Web\"/>\n    </httpModules>\n  </system.web>\n</configuration>\n```\n\n---"
      },
      {
        "heading": "Running Sitelets Alongside ASP.NET",
        "content": "### IIS 7.x+:\n\n```xml\n<configuration>\n  <system.webServer>\n    <modules>\n      <add name=\"WebSharper.RemotingModule\"\n           type=\"WebSharper.Web.RpcModule, WebSharper.Web\"/>\n      <add name=\"WebSharper.Sitelets\"\n           type=\"WebSharper.Sitelets.HttpModule, WebSharper.Sitelets\"/>\n    </modules>\n  </system.webServer>\n</configuration>\n```\n\n### IIS 6.x:\n\n```xml\n<configuration>\n  <system.web>\n    <httpModules>\n      <add name=\"WebSharper.RemotingModule\"\n           type=\"WebSharper.Web.RpcModule, WebSharper.Web\"/>\n      <add name=\"WebSharper.Sitelets\"\n           type=\"WebSharper.Sitelets.HttpModule, WebSharper.Sitelets\"/>\n    </httpModules>\n  </system.web>\n</configuration>\n```\n\n---"
      },
      {
        "heading": "Recommended Setup for New Applications",
        "content": "We recommend using a pure WebSharper Sitelets project instead of mixing with ASP.NET.\n\nHowever, the [Visual Studio Extension](https://developers.websharper.com/downloads) includes a template for hybrid apps.\n\n---\n\n**Source:** https://developers.websharper.com/docs/v4.x/fs/aspnet"
      }
    ]
  },
  {
    "filename": "websharper_aspnetcore.md",
    "sections": [
      {
        "heading": "Using WebSharper with ASP.NET Core",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/aspnetcore](https://developers.websharper.com/docs/v4.x/fs/aspnetcore)\n\nTo use WebSharper features in an ASP.NET Core web application, you will need the packages `WebSharper`, `WebSharper.FSharp` and `WebSharper.AspNetCore`. The easiest way to get started is to use one of the [templates](https://developers.websharper.com/docs/v4.x/fs/install#netcore).\n\nWebSharper can be enabled and configured in the `Configure` method, and uses a few services configured in the `ConfigureServices` method. Here is a recommended default setup:\n\n```fsharp\ntype Startup() =\n\n    member this.ConfigureServices(services: IServiceCollection) =\n        services.AddSitelet(mySitelet)\n                .AddAuthentication(\"WebSharper\")\n                .AddCookie(\"WebSharper\")\n        |> ignore\n\n    member this.Configure(app: IApplicationBuilder) =\n        app.UseAuthentication()\n            .UseWebSharper()\n            .UseStaticFiles()\n        |> ignore\n```\n\n---"
      },
      {
        "heading": "Configure Setup",
        "content": "### `UseWebSharper()`\n\nMake sure you `open WebSharper.AspNetCore` to use `UseWebSharper`.\n\n#### Basic Setup\n\n```fsharp\ntype Startup() =\n    member this.Configure(app: IApplicationBuilder) =\n        app.UseWebSharper()\n        |> ignore\n```\n\n#### With Builder Configuration\n\n```fsharp\ntype Startup() =\n    member this.Configure(app: IApplicationBuilder) =\n        app.UseWebSharper(fun builder ->\n            builder\n                .Sitelet(mySitelet)\n                .UseRemoting(false)\n            |> ignore)\n        |> ignore\n```\n\nBuilder methods available:\n\n- `UseSitelets(?u: bool)`\n- `UseRemoting(?u: bool)`\n- `Sitelet(s: Sitelet<'EndPoint>)`\n- `Config(c: IConfiguration)`\n- `Logger(l: ILogger)`\n- `BinDir(d: string)`\n- `AuthenticationScheme(s: string)`\n\n---\n\n### `UseStaticFiles()`\n\n```fsharp\napp.UseWebSharper()\n    .UseStaticFiles()\n```\n\n> Call `UseStaticFiles()` **after** `UseWebSharper()`.\n\n---\n\n### `UseAuthentication()`\n\n```fsharp\napp.UseAuthentication()\n    .UseWebSharper()\n    .UseStaticFiles()\n```\n\n> Call `UseAuthentication()` **before** `UseWebSharper()`.\n\n---"
      },
      {
        "heading": "ConfigureServices Setup",
        "content": "### Sitelets\n\n#### Basic:\n\n```fsharp\ntype Startup() =\n    member this.ConfigureServices(services: IServiceCollection) =\n        services.AddSitelet(mySitelet)\n```\n\n#### With DI:\n\n```fsharp\ntype MyWebsite() =\n    inherit SiteletService<MyEndPoint>()\n\n    let sitelet = Application.MultiPage(fun ctx endpoint ->\n        Content.Text \"Hello, world!\")\n\n    override this.Sitelet = sitelet\n\ntype Startup() =\n    member this.ConfigureServices(services: IServiceCollection) =\n        services.AddSitelet<MyWebsite>()\n```\n\n#### With Logger:\n\n```fsharp\ntype MyWebsite(logger: ILogger<MyWebsite>) =\n    inherit SiteletService<MyEndPoint>()\n\n    let sitelet = Application.MultiPage(fun ctx endpoint ->\n        logger.LogInformation(\"Serving a sitelet page!\")\n        Content.Text \"Hello, world!\")\n\n    override this.Sitelet = sitelet\n```\n\n---\n\n### Remoting\n\n#### Simple:\n\nNo configuration needed unless you call `UseRemoting(false)`.\n\n#### With DI:\n\n```fsharp\ntype MyRpc(logger: ILogger<MyRpc>) =\n\n    [<Remote>]\n    member this.MyMethod() =\n        logger.LogInformation(\"MyMethod was called\")\n\ntype Startup() =\n    member this.ConfigureServices(services: IServiceCollection) =\n        services.AddWebSharperRemoting<MyRpc>()\n        |> ignore\n```\n\n#### Abstract with Implementation:\n\n```fsharp\n[<AbstractClass>]\ntype MyRpc() =\n    [<Remote>]\n    abstract MyMethod : unit -> unit\n\ntype MyRpcImpl(logger: ILogger<MyRpc>) =\n    inherit MyRpc()\n    override this.MyMethod() =\n        logger.LogInformation(\"MyMethod was called\")\n\ntype Startup() =\n    member this.ConfigureServices(services: IServiceCollection) =\n        services.AddWebSharperRemoting<MyRpc, MyRpcImpl>()\n        |> ignore\n```\n\n---\n\n### Authentication\n\n```fsharp\ntype Startup() =\n    member this.ConfigureServices(services: IServiceCollection) =\n        services\n            .AddAuthentication(\"WebSharper\")\n            .AddCookie(\"WebSharper\")\n        |> ignore\n```\n\nAnd also use `app.UseAuthentication()` in `Configure()`.\n\n---"
      },
      {
        "heading": "Crawl Info",
        "content": "- **Source:** https://developers.websharper.com/docs/v4.x/fs/aspnetcore\n- **Depth:** 5\n- **Pages processed:** 1\n- **Crawl duration:** 2.89 seconds\n- **Crawl completed:** 2025-05-11 17:13"
      }
    ]
  },
  {
    "filename": "websharper_aspnetmvc.md",
    "sections": [
      {
        "heading": "Using WebSharper with ASP.NET MVC",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/aspnetmvc](https://developers.websharper.com/docs/v4.x/fs/aspnetmvc)\n\nWebSharper is self-sufficient and can run as the single component of a web application, but it can also be integrated into an existing ASP.NET MVC application. This integration is twofold:\n\n- Client-side WebSharper controls can be used within a Razor page.\n- Full WebSharper [sitelets](https://developers.websharper.com/docs/v4.x/fs/sitelets) can run alongside an ASP.NET application.\n\n---"
      },
      {
        "heading": "Required References",
        "content": "Add the following to your ASP.NET MVC project:\n\n- Your WebSharper project\n- [WebSharper.CSharp NuGet package](http://www.nuget.org/packages/WebSharper.CSharp/)\n- [WebSharper.AspNetMvc package](http://www.nuget.org/packages/WebSharper.AspNetMvc)\n- [FSharp.Core NuGet package](http://www.nuget.org/packages/FSharp.Core/)\n\n### Web.config Binding Redirect\n\n```xml\n<configuration>\n  <runtime>\n    <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n      <dependentAssembly>\n        <assemblyIdentity name=\"FSharp.Core\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n        <bindingRedirect oldVersion=\"0.0.0.0-4.4.3.0\" newVersion=\"4.4.3.0\" />\n      </dependentAssembly>\n    </assemblyBinding>\n  </runtime>\n</configuration>\n```\n\n---"
      },
      {
        "heading": "Integrating Client-Side Controls in ASP.NET Pages",
        "content": "WebSharper allows seamless client-server RPC calls.\n\n### C# Example\n\n```csharp\npublic static class Server\n{\n    [Remote]\n    public static Task<int[]> GetData()\n    {\n        return Task.FromResult(new[] { 1, 2, 3 });\n    }\n}\n\n[Serializable]\npublic class SimpleClientServerControl : WebSharper.Web.Control\n{\n    [JavaScript]\n    public override IControlBody Body\n    {\n        get\n        {\n            var model = new ListModel<int, int>(x => x);\n            Task.Run(async () =>\n            {\n                foreach (var n in await Server.GetData())\n                    model.Add(n);\n            });\n            return ul(model.View.DocSeqCached((int x) => li(\"Value= \", x)));\n        }\n    }\n}\n```\n\n### F# Example\n\n```fsharp\nnamespace WebSharperProject\n\nopen WebSharper\n\nmodule Server =\n    [<Rpc>]\n    let GetData () = async { return [1; 2; 3] }\n\nmodule Client =\n    open WebSharper.Html.Client\n\n    [<JavaScript>]\n    let Main () =\n        let ul = UL\n        async {\n            let! data = Server.GetData ()\n            for i in data do\n                ul.Append(LI [Text (\"Value= \" + i)])\n        } |> Async.Start\n        ul\n\ntype SimpleClientServerControl() =\n    inherit Web.Control()\n\n    [<JavaScript>]\n    override this.Body = Client.Main () :> _\n```\n\n---"
      },
      {
        "heading": "Razor Page Integration",
        "content": "1. In the layout file inside `<head>`:\n\n```razor\n@WebSharper.AspNetMvc.ScriptManager.Head()\n```\n\n2. In your view:\n\n```razor\n@{\n    var myControl = WebSharper.AspNetMvc.ScriptManager.Register(new MyControl());\n}\n<div>\n    <h1>My control:</h1>\n    @myControl\n</div>\n```\n\n3. Full example:\n\n```razor\n@{\n    var myControl = WebSharper.AspNetMvc.ScriptManager.Register(new MyControl());\n}\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>My sample Razor page</title>\n    @WebSharper.AspNetMvc.ScriptManager.Head()\n  </head>\n  <body>\n    <div>\n      <h1>My control:</h1>\n      @myControl\n    </div>\n  </body>\n</html>\n```\n\n---"
      },
      {
        "heading": "Enabling Remoting",
        "content": "### Web.config for IIS 7.x+:\n\n```xml\n<configuration>\n  <system.webServer>\n    <modules>\n      <add name=\"WebSharper.RemotingModule\"\n           type=\"WebSharper.Web.RpcModule, WebSharper.Web\"/>\n    </modules>\n</configuration>\n```\n\n### Web.config for IIS 6.x:\n\n```xml\n<configuration>\n  <system.web>\n    <httpModules>\n      <add name=\"WebSharper.RemotingModule\"\n           type=\"WebSharper.Web.RpcModule, WebSharper.Web\"/>\n    </httpModules>\n</configuration>\n```\n\n---"
      },
      {
        "heading": "Running Sitelets Alongside ASP.NET",
        "content": "Add this to `Web.config`:\n\n### IIS 7.x+:\n\n```xml\n<configuration>\n  <system.webServer>\n    <modules>\n      <add name=\"WebSharper.Sitelets\"\n           type=\"WebSharper.Sitelets.HttpModule, WebSharper.Sitelets\"/>\n    </modules>\n</configuration>\n```\n\n### IIS 6.x:\n\n```xml\n<configuration>\n  <system.web>\n    <httpModules>\n      <add name=\"WebSharper.Sitelets\"\n           type=\"WebSharper.Sitelets.HttpModule, WebSharper.Sitelets\"/>\n    </httpModules>\n</configuration>\n```\n\n### Route Handling Priority\n\n```csharp\npublic class MyMvcApplication : System.Web.HttpApplication\n{\n    protected void Application_Start()\n    {\n        WebSharper.Sitelets.HttpModule.OverrideHandler = false;\n    }\n}\n```\n\n---"
      },
      {
        "heading": "Crawl Info",
        "content": "- **Source:** https://developers.websharper.com/docs/v4.x/fs/aspnetmvc\n- **Depth:** 5\n- **Pages processed:** 1\n- **Crawl duration:** 3.06 seconds\n- **Crawl completed:** 2025-05-11 17:13"
      }
    ]
  },
  {
    "filename": "websharper_async.md",
    "sections": [
      {
        "heading": "Asynchronous Workflows",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/async](https://developers.websharper.com/docs/v4.x/fs/async)\n\nWebSharper supports [F# asynchronous workflows](http://msdn.microsoft.com/en-us/library/dd233250.aspx) on the client, implementing them with JavaScript callbacks.\n\nAn `async<'T>` workflow represents a program that can be invoked to either succeed with a result `'T` asynchronously or fail with an exception.\n\n---"
      },
      {
        "heading": "Client-Side Limitations",
        "content": "- **Single-threaded execution:** JavaScript runtimes are single-threaded, so all parallelism is cooperative.\n- **Implicit yielding:** Yielding of control happens implicitly in:\n  - `let` or `let!`\n  - Each iteration of `for`/`while` loops\n  - Between consecutive statements in `async { }` blocks\n- **No synchronous execution:** `Async.RunSynchronously` is not available on the client.\n- **Cancellation support:** Standard F#/NET cancellation tokens are supported. If a cancellation happens during an RPC call, the response will be ignored without decoding the result.\n\n---"
      },
      {
        "heading": "Crawl Info",
        "content": "- **Source:** https://developers.websharper.com/docs/v4.x/fs/async\n- **Depth:** 5\n- **Pages processed:** 1\n- **Crawl duration:** 2.98 seconds\n- **Crawl completed:** 2025-05-11 17:19"
      }
    ]
  },
  {
    "filename": "websharper_attributes.md",
    "sections": [
      {
        "heading": "WebSharper Attributes",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/attributes](https://developers.websharper.com/docs/v4.x/fs/attributes)\n\n---"
      },
      {
        "heading": "Attributes for Customizing Translation",
        "content": "The `WebSharper` namespace contains several attributes for customizing JavaScript compilation.\n\n### JavaScript\n\nMarks assemblies, classes, or members to be compiled to JavaScript.\n\nExamples:\n\n- `[<JavaScript>]` â€” include\n- `[<JavaScript(false)>]` â€” exclude\n- `[<assembly: JavaScript(\"TypeName\")>]` â€” compile specific type\n\n### Constant\n\nCompiles getter or union case to a constant value (`bool`, `int`, `string`, `double`).\n\n### Inline\n\nMarks members for inlining.\n\n- `[<Inline>]` â€” auto-inlines F# body\n- `[<Inline \"$a + $b\">]` â€” custom JavaScript expression\n- Template variables: `$0`, `$this`, `$value`, `$argName`\n\n### Direct\n\nSimilar to `Inline`, but produces a standalone function instead of inlining at each call.\n\n### Macro\n\nEnables custom compile-time transformation using macro types.\n\n### Pure\n\nMarks a method as having no side effects. Used for optimization.\n\n### Generated\n\nUses a type-based generator to dynamically create a JavaScript function.\n\n### Name\n\nAssigns a custom name in JavaScript translation.\n\n### Proxy\n\nAllows creating client-side implementations for .NET types.\n\n### Remote\n\nMarks a method as RPC-callable from client-side.\n\n### Require\n\nDeclares a dependency on a resource (`IResourceDefinition`).\n\n### Stub\n\nProvides default inline behavior for common operations.\n\n### RemotingProvider\n\nSpecifies which RPC provider to use on the client side.\n\n### OptionalField\n\nAllows `option`-typed fields to default to `None` if missing.\n\n### SPAEntryPoint\n\nMarks a static, no-argument method as the SPA entry point.\n\n---"
      },
      {
        "heading": "Attributes for Sitelets Routing & JSON",
        "content": "### DateTimeFormat\n\nCustom format for serializing/deserializing `DateTime`.\n\n### NamedUnionCases\n\nCustomize union type JSON representation (F# only).\n\n### EndPoint\n\nSpecifies the URL path handled by a class.\n\n### Method\n\nSpecifies HTTP method (`GET`, `POST`, etc.).\n\n### Json\n\nParses request body as JSON for the endpoint arguments.\n\n### Query\n\nParses values from the query string.\n\n### FormData\n\nParses form-data or URL-encoded body values.\n\n### Wildcard\n\nCaptures remaining URL path segments into an array.\n\n---"
      },
      {
        "heading": "Attribute Interactions",
        "content": "- `Stub` and `JavaScript` are inherited.\n- `JavaScript` takes precedence unless explicitly overridden.\n- `Proxy` implies `JavaScript`.\n- `Macro` disables inherited JavaScript unless fallback required.\n- `Remote` disables JavaScript translation.\n\n---"
      },
      {
        "heading": "Crawl Info",
        "content": "- **Source:** https://developers.websharper.com/docs/v4.x/fs/attributes\n- **Depth:** 5\n- **Pages processed:** 1\n- **Crawl duration:** 2.89 seconds\n- **Crawl completed:** 2025-05-11 17:15"
      }
    ]
  },
  {
    "filename": "websharper_bindings.md",
    "sections": [
      {
        "heading": "Developing Bindings to JavaScript Libraries",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/bindings](https://developers.websharper.com/docs/v4.x/fs/bindings)\n\nWebSharper enables seamless interop with JavaScript. This guide outlines techniques for building F# bindings to JavaScript libraries.\n\n---"
      },
      {
        "heading": "Overview",
        "content": "Binding development involves:\n\n- Writing stubs (functions, classes)\n- Providing static types and wrappers\n- Defining resources (CSS, JS)\n- Packaging the binding with configuration\n\n---"
      },
      {
        "heading": "Stubs",
        "content": "A **stub** is an F# representation of a JavaScript function or class.\n\n### Example JavaScript\n\n```js\nfunction counter() {\n  var value = 0;\n  return function () {\n    return value++;\n  };\n}\n\nfunction Counter() {\n  this.value = 0;\n  this.next = function () {\n    this.value++;\n    return this.value;\n  };\n}\n```\n\n### F# Stub\n\n```fsharp\nmodule Counter =\n\n    [<Name \"counter\">]\n    [<Stub>]\n    let makeCounter () : (unit -> int) = X<_>\n\n    [<Stub>]\n    type Counter() =\n        [<DefaultValue>]\n        val mutable value: int\n\n        [<Name \"next\">]\n        [<Stub>]\n        member this.Next() : int = 0\n```\n\n### Resulting JavaScript\n\n```js\nvar c = new Counter();\nc.next();\n```\n\n**Notes:**\n\n- `Stub` enables JavaScript usage\n- `X<_>` or `Unchecked.defaultof<_>` are safe for bodies\n- Use `Name` to override F#-inferred names\n\n---"
      },
      {
        "heading": "Static Typing",
        "content": "Provide clear types for all stubbed methods:\n\n- Scalars â†’ `string`, `int`, `double`, `bool`\n- Arrays:\n  - Fixed: tuple\n  - Mono: `T[]`\n  - Poly: `obj[]`\n- Functions â†’ `p1 * p2 * ... -> r`\n- Fixed strings â†’ use discriminated unions + `Constant`\n- Object shape â†’ use record types\n- Optionals â†’ use classes with `[<DefaultValue>]` fields\n\n### Example: Optional Configuration Object\n\n```fsharp\ntype ButtonConfiguration [<Inline \"{}\">] () =\n    [<DefaultValue>]\n    val mutable label: string\n\n    [<DefaultValue>]\n    val mutable onclick: unit -> unit\n\nlet cfg = new ButtonConfiguration(label = \"Click me!\")\n```\n\n---"
      },
      {
        "heading": "Packaging and Configuration",
        "content": "Use `Require` and `Resources.IResourceDefinition` to link JS/CSS files:\n\n- Annotate modules/classes with `[<Require(typeof<MyResources>)>]`\n- Automatically includes required assets when used\n- Frees user from manual tracking of dependencies\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_compilerSettings.md",
    "sections": [
      {
        "heading": "WebSharper Compiler Settings",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/project-variables](https://developers.websharper.com/docs/v4.x/fs/project-variables)\n\nWebSharper allows project customization via `.csproj` / `.fsproj` or `wsconfig.json` (preferred since v4.2).\n\n---"
      },
      {
        "heading": "Using `wsconfig.json`",
        "content": "Place a `wsconfig.json` in the same folder as your project file. Example:\n\n```json\n{\n  \"$schema\": \"https://websharper.com/wsconfig.schema.json\",\n  \"project\": \"site\",\n  \"outputDir\": \"wwwroot\",\n  \"sourceMap\": true,\n  \"downloadResources\": true\n}\n```\n\n---"
      },
      {
        "heading": "Equivalent in `.csproj` or `.fsproj`",
        "content": "Settings must be inside a `<PropertyGroup>`.  \nIf both `.fsproj` and `wsconfig.json` provide a value, the JSON takes precedence.\n\n---"
      },
      {
        "heading": "Available Settings",
        "content": "### `project`\n\n- **Required** (unless `outputDir` specified)\n- Type: `string`\n- Values:\n  - `Site`, `Web`, `Website`, `Export`\n  - `Library`\n  - `Extension`, `InterfaceGenerator`\n  - `Html`\n  - `Bundle`\n  - `BundleOnly`\n\n**Examples:**\n\n```json\n\"project\": \"Site\"\n```\n\n```xml\n<WebSharperProject>Site</WebSharperProject>\n```\n\n---\n\n### `outputDir`\n\n- Type: `string` (relative or absolute path)\n- Required if `project` is `Site` or unspecified\n\n**Examples:**\n\n```json\n\"outputDir\": \"some/folder\"\n```\n\n```xml\n<WebProjectOutputDir>some/folder</WebProjectOutputDir>\n```\n\n---\n\n### `sourceMap`\n\n- Type: `bool`\n- Default: `false`\n\n```json\n\"sourceMap\": true\n```\n\n```xml\n<WebSharperSourceMap>True</WebSharperSourceMap>\n```\n\n---\n\n### `warnOnly`\n\n- Type: `bool`\n- Treat errors as warnings\n\n```json\n\"warnOnly\": true\n```\n\n```xml\n<WebSharperErrorsAsWarnings>True</WebSharperErrorsAsWarnings>\n```\n\n---\n\n### `dce` (Dead Code Elimination)\n\n- Type: `bool`\n- Default: `true` (for `Bundle`/`BundleOnly`)\n\n```json\n\"dce\": false\n```\n\n```xml\n<WebSharperDeadCodeElimintation>False</WebSharperDeadCodeElimintation>\n```\n\n---\n\n### `downloadResources`\n\n- Type: `bool`\n- Default: `false`\n- Requires `UseDownloadedResources=true` in runtime config\n\n```json\n\"downloadResources\": true\n```\n\n```xml\n<WebSharperDownloadResources>True</WebSharperDownloadResources>\n```\n\n---\n\n### `analyzeClosures`\n\n- Type: `bool` or `\"MoveToTop\"`\n\n```json\n\"analyzeClosures\": \"MoveToTop\"\n```\n\n```xml\n<WebSharperAnalyzeClosures>MoveToTop</WebSharperAnalyzeClosures>\n```\n\n---\n\n### `javascript`\n\n- Type: `bool` or array of strings\n\n```json\n\"javascript\": [\"MyFile.fs\", \"MyNamespace.MyType\"]\n```\n\n_No equivalent in project file._\n\n---\n\n### `jsOutput`\n\n- Type: `string` (path to output `.js` file)\n\n```json\n\"jsOutput\": \"dist/output.js\"\n```\n\n---\n\n### `minJsOutput`\n\n- Type: `string` (path to minified `.js` file)\n\n```json\n\"minJsOutput\": \"dist/output.min.js\"\n```\n\n---\n\n### `useNetFxCompiler`\n\n- Type: `bool`\n- Force using the .NET Framework or .NET Core version\n\n```xml\n<WebSharperUseNetFxCompiler>True</WebSharperUseNetFxCompiler>\n```\n\n_Not configurable via JSON._\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_contributing.md",
    "sections": [
      {
        "heading": "Contributing to WebSharper",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/contributing](https://developers.websharper.com/docs/v4.x/fs/contributing)\n\nWebSharper is an open-source project â€” your contributions are welcome!\n\n---"
      },
      {
        "heading": "What to Contribute",
        "content": "- Bug fixes ([issue tracker](https://github.com/dotnet-websharper/core/issues))\n- Standard library improvements\n- Compiler enhancements\n- Documentation ([docs repo](https://github.com/dotnet-websharper/docs))\n- Feature suggestions via [Gitter chat](https://gitter.im/intellifactory/websharper)\n\n---"
      },
      {
        "heading": "How to Contribute",
        "content": "### Requirements\n\n- Works on Windows, Linux, macOS\n- [.NET SDK 6.x or newer](https://www.microsoft.com/net/download)\n\n---\n\n### Build from Command Line\n\n- Windows: `build.cmd`\n- Linux/macOS: `build.sh`\n\n**Common Targets:**\n\n- `build ws-builddebug` (default)\n- `build ws-buildrelease`\n- `build ws-package` (creates NuGet packages)\n- `build ws-clean`\n\n**Verbose Output:**\n\n- `build [target] -ef verbose`\n\n---\n\n### Development Environment\n\n- **Windows:** [Visual Studio 2022](https://visualstudio.microsoft.com/vs/)\n- **All platforms:** [VS Code](https://code.visualstudio.com/) with:\n  - `ionide-fsharp`\n  - `ms-vscode.csharp`\n\n#### Single-target Project Setup\n\nRun:\n\n```bash\n# Windows\ntools\\GenSingleFw.cmd\n\n# Unix/macOS\ntools/GenSingleFw.sh\n```\n\nOpen `netcore/WebSharper.sln` or `netfx/WebSharper.sln`.\n\n> Re-run `GenSingleFw` after modifying `.fsproj`/`.csproj`.\n\n---\n\n### Run Tests\n\n- WebSharper uses its own client-side test framework backed by [QUnit](https://qunitjs.com/).\n- Run `tests/Web` project to test via browser.\n\n**Run Instructions:**\n\n- In Visual Studio: set `tests/Web` as startup project\n- On Linux/macOS: navigate to `tests/Web` and run `xsp`\n\n---\n\n### Test Locally on Your Project\n\n1. Fix code in WebSharper repo\n2. Run: `build ws-package`\n3. Add local NuGet source to your project:\n\n**Paket:**\n\n```txt\nsource /path/to/websharper-repo/build\n```\n\n**NuGet.config:**\n\n```xml\n<configuration>\n  <packageSources>\n    <add key=\"local-websharper\" value=\"/path/to/websharper-repo/build\" />\n  </packageSources>\n</configuration>\n```\n\nUpdate packages:\n\n```bash\ndotnet add WebSharper\ndotnet add WebSharper.FSharp\ndotnet add WebSharper.CSharp\n```\n\n---\n\n### Project Structure\n\n#### Solutions\n\n- `WebSharper.Compiler.sln` â€” compiler & MSBuild tasks\n- `WebSharper.sln` â€” stdlib, tests, remoting, sitelets\n\n#### Notable Projects\n\n- `WebSharper.Core`, `Compiler`, `FSharp`, `CSharp`, `MSBuild.CSharp`\n- `WebSharper.Main`, `JavaScript`, `JQuery`, `Collections`, `Control`\n- `WebSharper.Sitelets`, `Sitelets.Offline`, `Web`, `Web.Tests`\n- `WebSharper.SPA.Tests`, `StaticHtml.Tests`, `Website`, `Tests`, `Testing`\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_cytoscape.md",
    "sections": [
      {
        "heading": "Cytoscape Integration with WebSharper",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/cytoscape](https://developers.websharper.com/docs/v4.x/fs/cytoscape)\n\n[Cytoscape.js](http://js.cytoscape.org) enables rendering large graphs with labeled nodes and weighted edges. WebSharper provides bindings to interact with Cytoscape directly from F#.\n\n---"
      },
      {
        "heading": "Configuration",
        "content": "### JavaScript Example\n\n```js\nlet cy = cytoscape({\n  container: document.getElementById(\"cy\"),\n  elements: [\n    { data: { id: \"a\" } },\n    { data: { id: \"b\" } },\n    { data: { id: \"ab\", source: \"a\", target: \"b\" } },\n  ],\n  style: [\n    {\n      selector: \"node\",\n      style: {\n        \"background-color\": \"#666\",\n        label: \"data(id)\",\n      },\n    },\n    {\n      selector: \"edge\",\n      style: {\n        width: 3,\n        \"line-color\": \"#ccc\",\n        \"target-arrow-color\": \"#ccc\",\n        \"target-arrow-shape\": \"triangle\",\n      },\n    },\n  ],\n  layout: {\n    name: \"grid\",\n    rows: 1,\n  },\n});\n```\n\n### F# Equivalent\n\n```fsharp\nlet cy =\n    Cytoscape(\n        CytoscapeOptions(\n            Container = Document.GetElementById(\"main\"),\n            Elements = [|\n                ElementObject(Data = ElementData(Id = \"a\"))\n                ElementObject(Data = ElementData(Id = \"b\"))\n                ElementObject(Data = ElementData(Id = \"ab\", Source = \"a\", Target = \"b\"))\n            |],\n            Style = [|\n                StyleConfig(\n                    selector = \"node\",\n                    style = New [\n                        \"background-color\" => \"#666\"\n                        \"label\" => \"data(id)\"\n                    ]\n                )\n                StyleConfig(\n                    selector = \"edge\",\n                    style = New [\n                        \"width\" => \"3\"\n                        \"line-color\" => \"#ccc\"\n                        \"target-arrow-color\" => \"#ccc\"\n                        \"target-arrow-shape\" => \"triangle\"\n                    ]\n                )\n            |],\n            Layout = LayoutOptions(Name = \"grid\", Rows = 1)\n        )\n    )\n```\n\n> Each JavaScript object has a corresponding F# config or options type.\n\n---"
      },
      {
        "heading": "Container Setup",
        "content": "You must assign the container div to the DOM before passing it:\n\n```fsharp\nlet myDiv = div []\nmyDiv |> Doc.RunById \"main\"\n\nlet cy =\n    Cytoscape(CytoscapeOptions(\n        Container = myDiv.Dom\n    ))\n```\n\nEnsure you have `<div id=\"main\"></div>` in your HTML.\n\n---"
      },
      {
        "heading": "Type Mappings",
        "content": "| JavaScript | F#          |\n| ---------- | ----------- |\n| `cy`       | `Cytoscape` |\n| `eles`     | `Eles`      |\n| `ele`      | `Ele`       |\n| `nodes`    | `Nodes`     |\n| `node`     | `Node`      |\n| `edges`    | `Edges`     |\n| `edge`     | `Edge`      |\n| `layout`   | `Layout`    |\n\n### Algorithm Return Types\n\n| Algorithm               | F# Type                 |\n| ----------------------- | ----------------------- |\n| `breadthFirstSearch`    | `BFS`                   |\n| `depthFirstSearch`      | `DFS`                   |\n| `dijkstra`              | `Dijkstra`              |\n| `aStar`                 | `AStar`                 |\n| `floydWarshall`         | `FW`                    |\n| `bellmanFord`           | `BF`                    |\n| `kruskal`               | `Eles`                  |\n| `kargerStein`           | `KargerStein`           |\n| `pageRank`              | `PageRank`              |\n| `degreeCentrality`      | `float`                 |\n| `closenessCentrality`   | `ClosenessCentrality`   |\n| `betweennessCentrality` | `BetweennessCentrality` |\n\n---"
      },
      {
        "heading": "Functions as Arguments",
        "content": "Use `JavaScript.Function.Of` to pass F# functions to Cytoscape.\n\n---"
      },
      {
        "heading": "Custom Data Fields",
        "content": "F# example for setting custom data:\n\n```fsharp\nlet myOptions = ElementData(Id = \"a\")\nmyOptions?custom <- \"myField\"\n\nElements = [| ElementObject(myOptions) |]\n```\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_extjs.md",
    "sections": [
      {
        "heading": "WebSharper ExtJS Extension",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/extjs](https://developers.websharper.com/docs/v4.x/fs/extjs)\n\n[Ext JS](http://www.sencha.com/products/extjs/) is a powerful HTML5+JavaScript UI framework. This WebSharper extension binds Ext JS to F# with a type-safe API.\n\n---"
      },
      {
        "heading": "Notes on Usage",
        "content": "Bindings are auto-generated from Ext JS docs and may require explicit type annotations using `As<_>`.\n\nFull API: [Ext JS Docs](http://docs.sencha.com/extjs/)\n\n---\n\n### Names and Casing\n\n- Class names match JavaScript (inside `Ext`)\n- Methods/properties use PascalCase\n- Disambiguations:\n  - Properties with same name as class â†’ postfix `Prop`\n  - Methods with same name â†’ prefix `Do`\n  - Static methods â†’ prefix `_`\n\n---\n\n### Configuration Objects\n\nUse `Ext.create(\"ClassName\", config)` in JS. In WebSharper, use `ExtCfg`.\n\n#### JavaScript\n\n```js\nExt.create(\"Ext.window.Window\", {\n  title: \"Hello\",\n  height: 200,\n  width: 400,\n}).show();\n```\n\n#### F#\n\n```fsharp\nExtCfg.window.Window(\n    Title = \"Hello\",\n    Height = 200,\n    Width = 400\n).Create().Show()\n```\n\nUse `.With(...)` for extending configs.\n\n---\n\n### Event Setters\n\nInstead of:\n\n```js\ncomponent.On(\"click\", handler);\n```\n\nUse:\n\n```fsharp\ncomponent.OnClick(handler)\n```\n\n---\n\n### Function Arguments\n\n- Typed when available in docs\n- Otherwise use `EcmaScript.Function` with `As`\n\n---\n\n### Object Arguments\n\nUse `ExtParam` nested types for complex object args.\n\n---\n\n### Enumerations\n\nEnums appear in `ExtEnum`.\n\n---"
      },
      {
        "heading": "Using Ext JS with WebSharper",
        "content": "Create a control like:\n\n```fsharp\ntype AppControl() =\n    inherit Web.Control()\n\n    [<JavaScript>]\n    override this.Body =\n        upcast Div [] |>! OnAfterRender (fun el ->\n            Ext.OnReady(As (fun () -> onReady el.Body), null, New [])\n        )\n```\n\nThen define `onReady` to use `ExtCfg.container.Viewport` etc.\n\n---\n\n### CDN Resources\n\nUse:\n\n```fsharp\n[<Require(typeof<Resources.ExtAll>)>]\n```\n\nThis includes the necessary JS/CSS from Sencha's CDN.\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_goldenLayout.md",
    "sections": [
      {
        "heading": "WebSharper Golden Layout Extension",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/golden-layout](https://developers.websharper.com/docs/v4.x/fs/golden-layout)\n\nWebSharper provides bindings to [Golden Layout](https://golden-layout.com/), a library for managing layouts of panels in web apps.\n\n---"
      },
      {
        "heading": "Stylesheets",
        "content": "Use `Require` attributes in correct order:\n\n```fsharp\n[<Require(typeof<GoldenLayout.Resources.BaseCss>)>]\n[<Require(typeof<GoldenLayout.Resources.LightTheme>)>]\n[<JavaScript>]\nmodule Client = ...\n```\n\n---"
      },
      {
        "heading": "ContentItem Config",
        "content": "Use type-safe factories instead of direct object fields.\n\n| Factory Method         | Signature                                      |\n| ---------------------- | ---------------------------------------------- |\n| `CreateComponent`      | `(Component * Item) -> GeneralItemConfig`      |\n| `CreateReactComponent` | `(ReactComponent * Item) -> GeneralItemConfig` |\n| `CreateStack`          | `(Stack * Item) -> GeneralItemConfig`          |\n| `CreateColumn`         | `Item -> GeneralItemConfig`                    |\n| `CreateRow`            | `Item -> GeneralItemConfig`                    |\n\nUse `GeneralItemConfig` only when needed for function returns.\n\n---\n\n### Example\n\n```fsharp\ntype State = { Text: string }\n\nlet helloComponent =\n    ItemFactory.CreateComponent(\n        Component(\"hello-component\", ComponentState = { Text = \"Hello, \" }),\n        Item(Title = \"Hello\", IsClosable = false)\n    )\n\nlet worldComponent =\n    ItemFactory.CreateComponent(\n        Component(\"world-component\", ComponentState = { Text = \"World!\" }),\n        Item(Title = \"World!\", IsClosable = false)\n    )\n\nlet mainContentItem =\n    ItemFactory.CreateRow(\n        Item(Content = [| helloComponent; worldComponent |], IsClosable = false)\n    )\n```\n\n---"
      },
      {
        "heading": "Layout Config",
        "content": "Use the `Layout` type. Optional fields:\n\n- `Settings: LayoutSettings`\n- `Dimensions: LayoutDimensions`\n- `Labels: LayoutLabels`\n- `Content: GeneralItemConfig[]`\n\nDocs: [Golden Layout Config](http://golden-layout.com/docs/Config.html)\n\n---"
      },
      {
        "heading": "Instantiating Layout",
        "content": "```fsharp\nlet layoutManager = GoldenLayout(Layout(Content = [| mainContentItem |]))\n```\n\n---"
      },
      {
        "heading": "Register Components",
        "content": "```fsharp\nlayoutManager.RegisterComponent(\"hello-component\", fun (container, s) ->\n    let state = s :?> State\n    h3 [text state.Text]\n    |> fun h -> h.Html\n    |> container.GetElement().Html\n    |> fun jq -> jq.Ignore\n)\n```\n\nRepeat for each component.\n\n---"
      },
      {
        "heading": "Initialising",
        "content": "```fsharp\nlayoutManager.Init()\n```\n\n---"
      },
      {
        "heading": "Events",
        "content": "All key types inherit from `EventEmitter`.\n\nUse enums like `LayoutEvent`:\n\n```fsharp\nlayoutManager.On(LayoutEvent.Initialised, fun args ->\n    Console.Log(\"Layout initialised.\")\n    Console.Log(args)\n)\n```\n\n---"
      },
      {
        "heading": "Examples",
        "content": "- [Programmatic tabs](http://try.websharper.com/snippet/adam.abonyi-toth/0000EM)\n- [Dynamic tab adding](http://try.websharper.com/snippet/adam.abonyi-toth/0000EN)\n- [Markdown editor preview](http://try.websharper.com/snippet/adam.abonyi-toth/0000EO)\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_highcharts.md",
    "sections": [
      {
        "heading": "WebSharper Highcharts Extension",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/highcharts](https://developers.websharper.com/docs/v4.x/fs/highcharts)\n\n[Highcharts](http://www.highcharts.com/) is a JavaScript library for interactive HTML5 charts. WebSharper provides typed bindings for Highcharts, Highstock, and Highmaps.\n\n---"
      },
      {
        "heading": "Chart Setup in WebSharper",
        "content": "Create a chart inside a `Web.Control` like so:\n\n```fsharp\nDiv [] |>! OnAfterRender (fun el ->\n    Highcharts.Create(\n        JQuery.Of el.Body,\n        HighchartsCfg(\n            // configuration here\n        )\n    )\n)\n```\n\n---"
      },
      {
        "heading": "Type Casting",
        "content": "When a property accepts multiple types (e.g. object or array), use:\n\n```fsharp\nAs<MyExpectedType>(...)\n```\n\nThis cast disappears from the generated JS, so functionality is preserved.\n\n---"
      },
      {
        "heading": "Resources",
        "content": "### Highcharts\n\n```fsharp\nopen IntelliFactory.WebSharper.Highcharts\n[<Require(typeof<Resources.Highcharts>)>]\n```\n\n### Highstock (includes Highcharts)\n\n```fsharp\n[<Require(typeof<Resources.Highstock>)>]\n```\n\n### Highmaps (use with Highcharts or Highstock)\n\n```fsharp\n[<Require(typeof<Resources.MapModuleForCharts>)>]\n[<Require(typeof<Resources.MapModuleForStock>)>]\n```\n\n---"
      },
      {
        "heading": "API References",
        "content": "- [Highcharts API](http://api.highcharts.com/highcharts)\n- [Highstock API](http://api.highcharts.com/highstock)\n- [Highmaps API](http://api.highcharts.com/highmaps)\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_install.md",
    "sections": [
      {
        "heading": "Installing WebSharper",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/install](https://developers.websharper.com/docs/v4.x/fs/install)\n\n---"
      },
      {
        "heading": "Installing for Visual Studio",
        "content": "Requirements:\n\n- [Visual Studio 2015 or later](http://www.microsoft.com/visualstudio/eng/downloads)\n  - With Web Developer Tools\n  - Visual F# Tools (for F# projects)\n\n### Installation Steps\n\n1. Download the `.vsix` file from [WebSharper downloads](http://websharper.com/downloads)\n2. Install it (restart Visual Studio if open)\n3. New templates will appear under `Visual C#` and `Visual F# > WebSharper`\n\nðŸ“· **Visual Studio Templates:**\n\n![VS Templates](https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/VisualStudioTemplates41.png)\n\n---"
      },
      {
        "heading": "Installing Templates for .NET Core/Standard",
        "content": "1. Install [.NET Core SDK 2.0+](https://www.microsoft.com/net/download/windows)\n2. Run:\n\n```bash\ndotnet new -i WebSharper.Templates\n```\n\nList templates:\n\n```bash\ndotnet new\n```\n\nCreate new WebSharper project:\n\n```bash\ndotnet new websharper-web       # C# default\ndotnet new websharper-web -lang F#  # for F#\n```\n\nðŸ“· **.NET Core Templates:**\n\n![.NET Core Templates](https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/NetCoreTemplates42.png)\n\n---"
      },
      {
        "heading": "Updating WebSharper in Projects",
        "content": "- Use the NuGet Package Manager\n- Core library: `WebSharper`\n- C# support: `WebSharper.CSharp`\n- F# support: `WebSharper.FSharp`\n\nYou can update existing Visual Studio projects using NuGet just like any other library.\n\n---"
      },
      {
        "heading": "Faster Compilation with NGen.exe (Windows)",
        "content": "Run this script in PowerShell (as Admin):\n\n```powershell\ntools\\runngen.ps1\n```\n\n- Found in `WebSharper.CSharp` or `WebSharper.FSharp` NuGet package tools folder\n- Speeds up tool launch via native image generation\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_introjs.md",
    "sections": [
      {
        "heading": "WebSharper IntroJS Extension",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/introjs](https://developers.websharper.com/docs/v4.x/fs/introjs)\n\n[IntroJS](http://introjs.com/) is a JavaScript library for creating guided tours and hints in web apps. This WebSharper binding allows integration with F# code.\n\n---"
      },
      {
        "heading": "Setup",
        "content": "Include themes before using IntroJS:\n\n```fsharp\n[<Require(typeof<WebSharper.IntroJS.Resources.MainTheme>)>]\n[<SPAEntryPoint>]\nlet Main () = ...\n```\n\n---"
      },
      {
        "heading": "Using Themes",
        "content": "To override styles with additional themes:\n\n```fsharp\n[<Require(typeof<WebSharper.IntroJS.Resources.MainTheme>)>]\n[<Require(typeof<WebSharper.IntroJS.Resources.ModernTheme>)>]\n[<SPAEntryPoint>]\nlet Main () = ...\n```\n\n> âš ï¸ Add custom theme **after** `MainTheme` to ensure proper override.\n\n---"
      },
      {
        "heading": "Creating Intros",
        "content": "Two ways to define steps:\n\n1. Add `data-step` and `data-intro` in HTML\n2. Use `IntroJs().AddSteps()` programmatically\n\n---"
      },
      {
        "heading": "Configuration in WebSharper",
        "content": "JavaScript-style:\n\n```js\nintroJs().addStep({\n  element: document.querySelectorAll(\"#step2\")[0],\n  intro: \"Ok, wasn't that fun?\",\n  position: \"right\",\n});\n```\n\nWebSharper-style:\n\n```fsharp\nIntroJs().AddStep(StepConfig(\n    Element = JS.Document.QuerySelectorAll(\"#step2\").[0],\n    Intro = \"Ok, wasn't that fun?\",\n    Position = \"right\"\n))\n```\n\n> The same pattern applies to other config objects as well.\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_json.md",
    "sections": [
      {
        "heading": "WebSharper JSON API",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/json](https://developers.websharper.com/docs/v4.x/fs/json)\n\nWebSharper provides easy JSON serialization for both F# and C# types, usable on both client and server. The structure is inferred from types and can be customized with attributes.\n\n---"
      },
      {
        "heading": "Server-side Usage",
        "content": "- **Parsing JSON**: Use `[<Json>]` attribute in Sitelets.\n- **Writing JSON**: Use `Content.Json`.\n\n### Functions:\n\n- `Serialize : 'T -> string`\n- `Deserialize : string -> 'T`\n\n---"
      },
      {
        "heading": "Client-side Usage",
        "content": "Modules on client also provide:\n\n- `Parse : string -> obj`\n- `Stringify : obj -> string`\n- `Encode : 'T -> obj`\n- `Decode : obj -> 'T`\n\n---"
      },
      {
        "heading": "Format Reference",
        "content": "### Base Types\n\n- `int`, `uint`, `float`, `decimal`, `string`, `bool`\n- Output matches primitive JS types\n\n### Collections\n\n- `list<'T>`, `'T[]`, `Set<'T>` â†’ JSON arrays\n- `Map<string, 'T>` â†’ flat JSON object\n- `Map<int, 'T>` â†’ array of key-value pairs\n\n### Tuples\n\n- Represented as JSON arrays\n\n### F# Records\n\nFlat JSON object. Use `[<Name \"custom-name\">]` to rename fields.\n\n### F# Unions\n\nUse `[<NamedUnionCases>]` for readable output.\n\n#### Discriminator Forms:\n\n- `[<NamedUnionCases \"kind\">]` â†’ adds `\"kind\"` field\n- `[<NamedUnionCases>]` â†’ inferred from unique field names\n\n#### Constant Cases\n\nUse `[<Constant \"value\">]` on parameterless union cases for flat representation.\n\n---"
      },
      {
        "heading": "Classes (C#)",
        "content": "Use `[Serializable]` and a default constructor.\n\nExample:\n\n```csharp\n[Serializable]\npublic class Name {\n    [Name(\"first-name\")] string firstName;\n    string lastName;\n}\n```\n\nProduces:\n\n```json\n{ \"first-name\": \"John\", \"lastName\": \"Doe\" }\n```\n\n---"
      },
      {
        "heading": "Optional Fields",
        "content": "Fields with `option<'T>` are omitted when `None`. `null` is also accepted as `None`.\n\n---"
      },
      {
        "heading": "DateTimes",
        "content": "Serialized as ISO 8601 strings. Customize with `[<DateTimeFormat>]`.\n\n```fsharp\n[<DateTimeFormat \"yyyy-MM-dd\">]\n```\n\n> âš ï¸ `DateTimeFormat` is only supported server-side.\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_jspdf.md",
    "sections": [
      {
        "heading": "WebSharper JsPDF Extension",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/jspdf](https://developers.websharper.com/docs/v4.x/fs/jspdf)\n\n[JsPDF](https://parall.ax/products/jspdf) is a JavaScript library for creating PDF documents in the browser. WebSharper provides a binding to integrate this functionality with F#.\n\n---"
      },
      {
        "heading": "Creating a JsPDF Document",
        "content": "Instantiate a new document:\n\n```fsharp\nlet doc = new JsPDF()\n```\n\nYou can now use the full JsPDF API as you would in JavaScript.\n\n---"
      },
      {
        "heading": "Example",
        "content": "```fsharp\nlet doc = new JsPDF()\n\ndoc.Text(\"Hello world!\", 10., 10., obj) |> ignore\ndoc.AddPage()\ndoc.Text(\"Hello world on Page 2!\", 10., 10., obj) |> ignore\ndoc.Save(\"a4.pdf\")\n```\n\nThis will create a PDF with two pages and save it as `a4.pdf`.\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_math.md",
    "sections": [
      {
        "heading": "WebSharper Math Support",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/math](https://developers.websharper.com/docs/v4.x/fs/math)\n\nWebSharper supports advanced mathematical operations via [MathJS](http://mathjs.org/) and [MathJax](https://www.mathjax.org/). Some type handling differs from JavaScript and uses wrappers like `MathNumber`.\n\n---"
      },
      {
        "heading": "Basic Usage",
        "content": "JavaScript:\n\n```js\nmath.add(\"5\", 1.7, true);\n```\n\nF# WebSharper:\n\n```fsharp\nMath.Add(MathNumber(\"5\"), MathNumber(1.7), MathNumber(true))\n```\n\nIf all arguments are of the same type (`float`, `int`, or `Math.Unit`), wrapping is not required.\n\n---"
      },
      {
        "heading": "Big Numbers (`bigint`)",
        "content": "F#:\n\n```fsharp\nlet myBignum = bigint 100\nlet myBignumFromString = Math.Bignumber(\"100\")\nlet sum = myBignum + myBignum\n```\n\n---"
      },
      {
        "heading": "Complex Numbers",
        "content": "```fsharp\nlet myComplex = Complex(1., 1.)\nlet myComplexFromString = Math.Complex(\"1 + 1i\")\nlet sum = myComplex + myComplex\n```\n\n---"
      },
      {
        "heading": "Fractions",
        "content": "```fsharp\nlet f1 = Math.Fraction(\"1/2\")\nlet f2 = Math.Fraction(1, 2)\nlet f3 = Math.Fraction(0.5)\n```\n\n---"
      },
      {
        "heading": "Vectors",
        "content": "```fsharp\nlet v = [| 1.; 2.; 3. |]\nlet sum = Math.Add(MathNumber(v), MathNumber(v))\n```\n\n---"
      },
      {
        "heading": "Matrices",
        "content": "```fsharp\nlet m = [| [| 1.; 2. |]; [| 3.; 4. |] |]\nlet sum = Math.Add(MathNumber(m), MathNumber(m))\n```\n\n---"
      },
      {
        "heading": "Units",
        "content": "```fsharp\nlet u1 = Math.Unit(5, \"cm\")\nlet u2 = Math.Unit(\"5 cm\")\n```\n\nOperations automatically handle unit conversions.\n\n---"
      },
      {
        "heading": "Expressions & Rendering",
        "content": "Using `Math.Derivative` and MathJax:\n\n```fsharp\nlet expr = Math.Derivative(\"x^2 + x\", \"x\")\nlet tex = expr.ToTex()\n// Use MathJax to render `tex` string\n```\n\n> Other results can be converted to `Node` via `Math.Parse()`.\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_mathjax.md",
    "sections": [
      {
        "heading": "WebSharper MathJax Integration",
        "content": "**Source:** [https://developers.websharper.com/docs/v4.x/fs/mathjax](https://developers.websharper.com/docs/v4.x/fs/mathjax)\n\n[MathJax](https://mathjax.org) is a JavaScript tool for rendering math expressions from TeX, MathML, and AsciiMath formatted text. WebSharper provides bindings for configuring and using MathJax in F# applications.\n\n---"
      },
      {
        "heading": "Configuring MathJax",
        "content": "Use `MathJax.Config()` in WebSharper to configure MathJax just like the JS version:\n\n### JavaScript\n\n```js\nMathJax.Hub.Config({\n  extensions: [\"tex2jax.js\"],\n  jax: [\"input/TeX\", \"output/HTML-CSS\"],\n  tex2jax: {\n    inlineMath: [\n      [\"$\", \"$\"],\n      [\"(\", \")\"],\n    ],\n  },\n});\n```\n\n### WebSharper\n\n```fsharp\nMathJax.Hub.Config(\n    MathJax.Config(\n        Extensions = [| \"tex2jax.js\" |],\n        Jax = [| \"input/TeX\"; \"output/HTML-CSS\" |],\n        Tex2jax = MathJax.Tex2jax(\n            InlineMath = [| (\"$\", \"$\"); (\"\\(\", \"\\)\") |]\n        )\n    )\n)\n```\n\n### Example HTML\n\n```html\n<p>This is inline math: $a \\ne 0$ or \\(a \\ne 0\\)</p>\n<p>This is display math: $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$</p>\n```\n\n---"
      },
      {
        "heading": "Input Format Support",
        "content": "| Format    | Extension            | Jax Include         |\n| --------- | -------------------- | ------------------- |\n| TeX       | `\"tex2jax.js\"`       | `\"input/TeX\"`       |\n| MathML    | `\"mml2jax.js\"`       | `\"input/MathML\"`    |\n| AsciiMath | `\"asciimath2jax.js\"` | `\"input/AsciiMath\"` |"
      },
      {
        "heading": "Output Format Support",
        "content": "| Format      | Jax Include            |\n| ----------- | ---------------------- |\n| CommonHtml  | `\"output/CommonHTML\"`  |\n| HTML-CSS    | `\"output/HTML-CSS\"`    |\n| NativeMML   | `\"output/NativeMML\"`   |\n| SVG         | `\"output/SVG\"`         |\n| PreviewHTML | `\"output/PreviewHTML\"` |\n| PlainSource | `\"output/PlainSource\"` |\n\n---"
      },
      {
        "heading": "Nested Config Objects",
        "content": "JavaScript:\n\n```js\nmenuSettings: {\n    zoom: \"None\",\n    CTRL: false,\n    errorSettings: {\n        message: [\"[Math Processing Error]\"]\n    }\n}\n```\n\nWebSharper:\n\n```fsharp\nlet menuSettings = MathJax.MenuSetting(\n    Zoom = \"None\",\n    CTRL = false,\n    ErrorSettings = MathJax.ErrorSetting(\n        Message = [| \"[Math Processing Error]\" |]\n    )\n)\n```\n\n---"
      },
      {
        "heading": "Rendering Dynamic Content",
        "content": "To render dynamically calculated math expressions, use the MathJax queue:\n\n### Whole Page\n\n```fsharp\nMathJax.Hub.Queue([| \"Typeset\"; MathJax.Hub :> obj |])\n```\n\n### Specific DOM Element\n\nUse similar syntax with the target element instead of `MathJax.Hub`.\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_mathjs.md",
    "sections": [
      {
        "heading": "MathJS",
        "content": "[MathJS](http://mathjs.org/) is a powerful math JavaScript library. It allows the usage of big numbers, complex numbers, units, fractions with high precision, vectors or matrices. In WebSharper using these types and functions are the same with a few exceptions."
      },
      {
        "heading": "MathNumber",
        "content": "MathJS allows you to use many different types in a single function, but in F# it's harder to achieve. To solve this problem we have introduced the `MathNumber` type. `MathNumber` has a constructor with every useable type from MathJS and serves as a wrapper for these functions. Note that if you use `MathNumber` as parameters, the return type will be wrapped in `MathNumber` as well.\n\n### Supported types in MathNumber()\n\n- float[]\n- float[][]\n- float\n- float32\n- System.Numerics.BigInteger\n- System.Numerics.Complex\n- string\n- bool\n- int8\n- int16\n- int32\n- int64\n- uint8\n- uint16\n- uint32\n- uint64\n\n### Using MathNumber\n\nTo use different types in a function, we have to wrap the parameters in `MathNumber`. For example:\n\n**JavaScript**:\n\n```js\nmath.add(\"5\", 1.7, true);\n```\n\n**WebSharper**:\n\n```fsharp\nMath.Add(MathNumber(\"5\"), MathNumber(1.7), MathNumber(true))\n```\n\nThere are exceptions when we don't have to use the `MathNumber` wrapper:\n\n- If every parameter is a `float` or `int` (most commonly used types in math)\n- If every parameter is a `Math.Unit` type.\n- Some functions where only Vectors or Matrices are accepted"
      },
      {
        "heading": "Operations",
        "content": "With MathJS WebSharper allows you to use the `System.Numerics.Biginteger` (`bigint`) and the `System.Numerics.Complex` types' own .Net operations and functions. For example:\n\n```fsharp\n// When you'd write\nMath.Add(MathNumber(Complex(5., 2.)), MathNumber(Complex(3., 1.)))\n\n// You can just use the (+) operator\nComplex(5., 2.) + Complex(3., 1.)\n\n// Or we could use the Complex methods\nComplex.Log10(Complex(5., 2.))\n```\n\nThe same goes for `bigint` and the other types."
      }
    ]
  },
  {
    "filename": "websharper_mathrender.md",
    "sections": [
      {
        "heading": "Rendering math with WebSharper",
        "content": "Rendering math expressions in WebSharper works with the [MathJax](https://www.mathjax.org/) JavaScript library. The documentation for MathJax extension can be found [here](https://github.com/intellifactory/websharper.mathjax/blob/master/doc/doc.md).\n\nMathJax, so WebSharper too allows you to use a variety of common math formatting systems but not only that, it supports more than one output formatting systems."
      },
      {
        "heading": "Supported input formats",
        "content": "| Format    | Extension          | Jax include       |\n| --------- | ------------------ | ----------------- |\n| TeX       | `tex2jax.js`       | `input/TeX`       |\n| MathML    | `mml2jax.js`       | `input/MathML`    |\n| AsciiMath | `asciimath2jax.js` | `input/AsciiMath` |"
      },
      {
        "heading": "Supported output formats",
        "content": "| Format      | Jax include          |\n| ----------- | -------------------- |\n| CommonHtml  | `output/CommonHTML`  |\n| HTML-CSS    | `output/HTML-CSS`    |\n| NativeMML   | `output/NativeMML`   |\n| SVG         | `output/SVG`         |\n| PreviewHTML | `output/PreviewHTML` |\n| PlainSource | `output/PlainSource` |"
      },
      {
        "heading": "Rendering expressions",
        "content": "To render static expressions (it's part of the static HTML file or generated with WebSharper to the HTML file at the beginning) we don't have to do anything else but configure MathJax ([see an example here](https://github.com/intellifactory/websharper.mathjax/blob/master/doc/doc.md)).\n\nIn these examples we render dynamically changing formulas. In order to do that we have to use and call the `MathJax.Hub.Queue` on every update.\n\n### TeX\n\nTo render TeX expressions we have to include `\"input/TeX\"` in the Jax config, and `\"tex2jax.js\"` in the extensions. ([TeX documentation](https://en.wikibooks.org/wiki/TeX/def))\n\n### MathML\n\nTo render MathML expressions we have to include `\"input/MathML\"` in the Jax config, and `\"mml2jax.js\"` in the extensions. ([MathML documentation](https://www.w3.org/TR/MathML/))\n\n### Ascii Math\n\nTo render AsciiMath expressions we have to include `\"input/AsciiMath\"` in the Jax config, and `\"asciimath2jax.js\"` in the extensions. ([AsciiMath documentation](http://asciimath.org/))"
      }
    ]
  },
  {
    "filename": "websharper_mediumeditor.md",
    "sections": [
      {
        "heading": "Medium Editor",
        "content": "[Medium Editor](http://yabwe.github.io/medium-editor/) grants a new, easy to use text editor written in JavaScript. The library aims to replicate [Medium.com](https://medium.com)'s text editor which is a big blog website."
      },
      {
        "heading": "Getting started",
        "content": "To set up the extension all we need is a target div (or text field if we want to keep our formatted text in the DOM), and initializing the MediumEditor from F#.\n\nIn the HTML file, we need an element with a class, for example `editable`:\n\n```html\n<textarea class=\"editable\"></textarea>\n```\n\nIf we have this, we can access this with our MediumEditor like this:\n\n```fsharp\nlet editor = MediumEditor(\".editable\")\n```\n\nWith this, we're ready to use our default editor."
      },
      {
        "heading": "Configure Medium Editor",
        "content": "The editor comes with a lot of settings. We can set it up in its constructor with the `MediumEditorOptions` record type, like this:\n\n```fsharp\nlet editor =\n    MediumEditor(\n        \".editable\",\n        MediumEditorOptions(\n            ActiveButtonClass = \"medium-editor-button-active\",\n            AllowMultiParagraphSelection = true,\n            ButtonLabels = false,\n            Delay = 0,\n            DisableReturn = false,\n            DisableDoubleReturn = false,\n            DisableExtraSpaces = false,\n            DisableEditing = false\n        )\n    )\n```\n\nSee the options in the [original documentation](https://github.com/yabwe/medium-editor/blob/master/OPTIONS.md).\n\nEvery field where we have to give an object has its own record type. If the element could be disabled by giving a `false` value, we have to use Unions. This table shows the field-record pairs and the Union type if it needs one:\n\n| Field              | Record type               | Has union |\n| ------------------ | ------------------------- | --------- |\n| `toolbar`          | `ToolbarOptions`          | Yes       |\n| `anchor`           | `AnchorOptions`           | No        |\n| `placeholder`      | `PlaceholderOptions`      | Yes       |\n| `anchorPreview`    | `AnchorPreviewOptions`    | Yes       |\n| `paste`            | `PasteOptions`            | No        |\n| `keyboardCommands` | `KeyboardCommandsOptions` | Yes       |\n| `link`             | `LinkOptions`             | No        |\n| `parse`            | `ParseOptions`            | No        |"
      }
    ]
  },
  {
    "filename": "websharper_mvuOverview.md",
    "sections": [
      {
        "heading": "WebSharper.Mvu",
        "content": "WebSharper.Mvu provides an [Elm](https://guide.elm-lang.org/architecture/)-inspired MVU (Model-View-Update) architecture for WebSharper client-side applications.\n\nIt is based on [WebSharper.UI](https://developers.websharper.com/docs/v4.x/fs/ui) for its reactivity and HTML rendering."
      },
      {
        "heading": "The MVU architecture",
        "content": "Model-View-Update (MVU) is an architecture that stores the application's state in a single immutable **Model**. This model is rendered into the UI by a **Render** function and updated via a pure **Update** function that reacts to user actions or events."
      },
      {
        "heading": "Features",
        "content": "### Time-travel Debugging with RemoteDev\n\nAllows inspection of past states and messages:\n\n```fsharp\nApp.Create initialModel update render\n|> App.WithRemoteDev (RemoteDev.Options(hostname = \"localhost\", port = 8000))\n|> App.Run\n```\n\n### Automatic Local Storage\n\nPreserve model state across page reloads:\n\n```fsharp\nApp.Create initialModel update render\n|> App.WithLocalStorage \"key\"\n|> App.Run\n```\n\nNote: Add `WithLocalStorage` before `WithRemoteDev` if using both.\n\n### HTML Templating\n\nUse strongly-typed HTML templates from `.html` files to separate logic and presentation.\n\n### Paging\n\nCreate multi-page SPAs using the `Page` type, enabling transitions and reactive page content.\n\n### Routing\n\nBind the browser's URL to your model with a WebSharper router:\n\n```fsharp\nApp.Create initialModel update render\n|> App.WithRouting (Router.Infer<EndPoint>()) (fun model -> model.EndPoint)\n|> App.Run\n```"
      },
      {
        "heading": "Differences with Other MVU Libraries",
        "content": "Unlike React-based MVU where views re-render on each change, WebSharper.Mvu uses reactive `View<Model>` values. The render function is called once, and DOM updates reactively as the `View` changes."
      },
      {
        "heading": "Examples",
        "content": "- [Simple counter](http://try.websharper.com/#/snippet/loic.denuziere/0000Kf)\n- [Counter list](http://try.websharper.com/#/snippet/loic.denuziere/0000Kg)\n- [Paging](http://try.websharper.com/snippet/loic.denuziere/0000Kc)\n- [TodoMVC](http://try.websharper.com/#/snippet/loic.denuziere/0000Kj)"
      },
      {
        "heading": "Resources",
        "content": "- [WebSharper](https://websharper.com)\n- [WebSharper UI](https://developers.websharper.com/docs/v4.x/fs/ui)\n- [WebSharper Forums](https://forums.websharper.com)"
      }
    ]
  },
  {
    "filename": "websharper_mvuRemoteDev.md",
    "sections": [
      {
        "heading": "RemoteDev integration",
        "content": "WebSharper.Mvu integrates seamlessly with [RemoteDev](https://github.com/zalmoxisus/remotedev). This tool allows you to inspect the successive messages and states of your model, and even to replay old states and see the effect on your view.\n\n![RemoteDev screenshot](https://raw.githubusercontent.com/dotnet-websharper/mvu/master/docs/images/remotedev.png)"
      },
      {
        "heading": "Installing and starting the tool",
        "content": "RemoteDev can be used in multiple ways, documented on [its website](https://github.com/zalmoxisus/remotedev). We recommend the following setup:\n\n- Start the remotedev server:\n\n      $ npm install -g remotedev-server     # Run once to install the server\n      $ remotedev                           # Start the remotedev server\n\n- Install and start the [Redux devtools extension](https://github.com/zalmoxisus/redux-devtools-extension#installation) for your browser.\n\nNote that at the time of writing, `remotedev-server` is compatible with nodejs 6.x, but not 8.x."
      },
      {
        "heading": "Code integration",
        "content": "RemoteDev integration is applied using a single call to `App.WithRemoteDev`, which takes RemoteDev options as argument. Here is an example with options appropriate for use with `remotedev-server`:\n\n```fsharp\nlet Main() =\n    App.Create initialModel update render\n    |> App.WithRemoteDev (RemoteDev.Options(hostname = \"localhost\", port = 8000))\n    |> App.Run\n```\n\nThis integration uses WebSharper.Json serialization to communicate with RemoteDev. The tool expects message values to be objects with a `\"type\"` field; therefore, you should use as Message type a discriminated union annotated like follows:\n\n```fsharp\n[<NamedUnionCases \"type\">]\ntype Message =\n    | Message1 of id: int * value: string\n    | // other message types...\n```\n\nGiven the above, the value:\n\n```fsharp\nMessage1 (42, \"Hello world!\")\n```\n\nwill be sent to RemoteDev as:\n\n```json\n{ \"type\": \"Message1\", \"id\": 42, \"value\": \"Hello world!\" }\n```"
      }
    ]
  },
  {
    "filename": "websharper_overview.md",
    "sections": [
      {
        "heading": "WebSharper Overview",
        "content": "WebSharper is an [F#](http://fsharp.org)-based web programming platform including compilers from F# and C# code to JavaScript."
      },
      {
        "heading": "Topics Covered",
        "content": "- Building and contributing\n- Installing\n- Running applications\n- Hello world\n- SPA & MPA patterns\n- Client-side functionality\n- JavaScript libraries\n- REST applications\n- Resources and links"
      },
      {
        "heading": "Getting Started",
        "content": "WebSharper is open source and contributions are welcome!  \nSee [contributing guide](https://developers.websharper.com/docs/v4.x/fs/contributing) and [report issues](https://github.com/dotnet-websharper/core/issues)."
      },
      {
        "heading": "Installation",
        "content": "Use WebSharper project templates for:\n\n- [Visual Studio](http://websharper.com/docs/install)\n- [.NET Core CLI via `dotnet new`](https://github.com/fsprojects/generator-fsharp)\n\nOr create your project manually by:\n\n- Starting from an F# library project\n- Installing `WebSharper` via [Paket](https://fsprojects.github.io/Paket/)\n- Setting `<WebSharperProject>` in your project file (values: `Html`, `Site`, `Bundle`)\n- Adding required targets like `Microsoft.WebApplication.targets`"
      },
      {
        "heading": "Running WebSharper Applications",
        "content": "Supported backends:\n\n- **ASP.NET Core/IIS**: annotate main sitelet with `[<Website>]`\n- **Suave** (F# lightweight server): use `WebSharper.Suave.WebSharperAdapter.ToWebPart(...)`"
      },
      {
        "heading": "Hello World Example",
        "content": "```fsharp\n[<Website>]\nlet Main = Application.Text (fun ctx -> \"Hello World!\")\n```"
      },
      {
        "heading": "SPA Example",
        "content": "```fsharp\n[<Website>]\nlet Main =\n    Application.SinglePage (fun ctx ->\n        Content.Page(h1 [] [text \"Hello World!\"])\n    )\n```"
      },
      {
        "heading": "MPA Example",
        "content": "```fsharp\ntype Endpoints =\n    | [<EndPoint \"GET /\">] Home\n    | [<EndPoint \"GET /about\">] About\n\n[<Website>]\nlet Main =\n    Application.MultiPage (fun ctx endpoint ->\n        match endpoint with\n        | Home -> Content.Page(Body = [h1 [] [text \"Hello world!\"]])\n        | About -> Content.Page(Body = [p [] [text \"This is a simple app\"]])\n    )\n```"
      },
      {
        "heading": "Client-Side Functionality",
        "content": "Add `[<JavaScript>]` for client code, `[<Rpc>]` for server functions.\n\n```fsharp\n[<Rpc>]\nlet DoWork (s: string) =\n    async { return new string(Array.rev (s.ToCharArray())) }\n```"
      },
      {
        "heading": "Using JavaScript Libraries",
        "content": "Example using [WebSharper.Charting](https://github.com/intellifactory/websharper.charting):\n\n```fsharp\nlet RadarChart () =\n    let ch = Chart.Radar([(\"Eating\", 10.); (\"Coding\", 90.)])\n    Renderers.ChartJs.Render(ch, Size = Size(400, 400))\n```"
      },
      {
        "heading": "Resources",
        "content": "- [Documentation](https://developers.websharper.com)\n- [Downloads](http://websharper.com/downloads)\n- [Examples](https://try.websharper.com)\n- [GitHub](https://github.com/dotnet-websharper/core)\n- [Gitter](https://gitter.im/intellifactory/websharper)"
      }
    ]
  },
  {
    "filename": "websharper_owin.md",
    "sections": [
      {
        "heading": "WebSharper.Owin",
        "content": "The `WebSharper.Owin` project provides hosting options for WebSharper Sitelets applications using [OWIN](http://owin.org/). For example, it enables compiling a Sitelet into a self-contained executable that runs a self-hosted website using [Katana](https://katanaproject.codeplex.com/).\n\nAvailable from [NuGet](http://nuget.org/packages/websharper.owin) Â· [Source on GitHub](https://github.com/intellifactory/websharper.owin)"
      },
      {
        "heading": "OWIN Middleware",
        "content": "WebSharper.Owin provides two middleware classes:\n\n### `RemotingMiddleware`\n\nServes WebSharper RPC functions. Can be instantiated with:\n\n- `Options`\n- `webRoot` and `meta`\n- `meta` only\n- `webRoot` and optional `binDirectory`\n\nYou can use either the class constructor with `.Invoke` or the static `.AsMidFunc`.\n\n### `SiteletMiddleware`\n\nServes a provided `Sitelet<'T>`. Can be instantiated with:\n\n- `Options` and `Sitelet<'T>`\n- `webRoot`, `Sitelet<'T>`, and optional `binDirectory`\n- `Create(webRoot, ?binDirectory)` â€“ discovers sitelet in assemblies\n\n**Note:** `RemotingMiddleware` must appear _before_ `SiteletMiddleware` in your middleware stack. `SiteletMiddleware` does not serve static filesâ€”you'll need something like `Microsoft.Owin.StaticFiles`."
      },
      {
        "heading": "Katana `IAppBuilder` Extension Methods",
        "content": "Use these helpers to integrate WebSharper OWIN middleware:\n\n- `UseRemoting`\n- `UseCustomSitelet`\n- `UseSitelet`\n- `UseDiscoveredSitelet`\n\nThey map directly to the respective middleware classes above."
      },
      {
        "heading": "Options",
        "content": "Create `Options` using:\n\n- `Options.Create()` â€“ no RPC\n- `Options.Create(meta: Metadata.Info)`\n- `Options.Create(webRoot: string, ?binDirectory: string)`\n\nCustomize with:\n\n- `.WithDebug()` or `.WithDebug(bool)`\n- `.WithServerRootDirectory(string)`\n- `.WithUrlPrefix(string)`\n- `.WithRunRemoting(bool)` â€“ defaults to `true`"
      }
    ]
  },
  {
    "filename": "websharper_proxying.md",
    "sections": [
      {
        "heading": "Developing Proxies to .NET Libraries",
        "content": "**Proxying** in WebSharper is the process of providing JavaScript-compilable F# implementations for classes and modules that were compiled without WebSharper, such as Base Class Library types like `Dictionary`. Proxying maps original types to JavaScript-compatible proxy implementations using `Proxying.AbstractProxyAttribute`.\n\n### Example: Proxying a Generic Dictionary\n\n```fsharp\nopen System.Collections.Generic\n\n[<Proxy(typeof<Dictionary<_, _>>)>]\n[<JavaScript>]\ntype MyDictionary<'K, 'V>() =\n    let mutable count = 0\n    member this.Count = count\n```\n\nProjects referencing the above code can use `Dictionary<_, _>` in client-side code, and `MyDictionary` will be used in its place during JavaScript compilation.\n\n### Example: Proxying a Module\n\nIf proxying a module or using `typeof` is not possible, specify the full type name:\n\n```fsharp\n[<Proxy \"Microsoft.FSharp.Collections.ArrayModule, FSharp.Core, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\">]\nmodule MyArrayModule =\n    [<Inline \"$0.length\">]\n    let length<'T> (arr : 'T[]) = 0\n```\n\n### Notes on Developing Proxy Code\n\n- The `ProxyAttribute` string must match the `FullName` of the generic type definition.\n- Proxy member names, types, arguments, and calling conventions must exactly match those of the original.\n- Partial proxies are allowed: client-side calls to unimplemented members will fail."
      }
    ]
  },
  {
    "filename": "websharper_remarkable.md",
    "sections": [
      {
        "heading": "WebSharper.Remarkable",
        "content": "WebSharper Extension for remarkable 1.7.1"
      },
      {
        "heading": "About the library",
        "content": "Remarkable is a markdown parser written in JavaScript. It is easy to use and can be easily configured.\n\nThe WebSharper extension works similarly to the original Remarkable."
      },
      {
        "heading": "How to use it",
        "content": "You can either configure it or just start using it with its default settings.\n\n### Available Options\n\n- **Html**: Enable HTML tags in source (default: false)\n- **XhtmlOut**: Use â€˜/â€™ to close single tags (default: false)\n- **Breaks**: Convert `\\n` in paragraphs into `<br>` (default: false)\n- **LangPrefix**: CSS language prefix for fenced blocks (default: â€˜language-â€™)\n- **Linkify**: Autoconvert URL-like text to links (default: false)\n- **Typographer**: Enable some language neutral-replacement (default: false)\n- **Quotes**: Set doubles to 'Â«Â»' for Russian, 'â€žâ€œ' for German (default: 'â€œâ€â€˜â€™')\n- **Highlight**: Highlighter function. Should return escaped HTML, or `\"\"` if the source string is not changed.\n\n### Example\n\n```fsharp\nlet RemarkableConfig = new Options()\nRemarkableConfig.Html <- false\nRemarkableConfig.XhtmlOut <- false\nRemarkableConfig.Breaks <- false\nRemarkableConfig.Linkify <- true\n\nlet Md = new Remarkable(RemarkableConfig)\n\nMd.Render(\"# Hello world!\")\n|> Doc.Verbatim\n|> Doc.RunById \"main\"\n```\n\n### `.Set` Method\n\nThe `.Set` method takes an `Options` and returns unit. This lets you change configuration on the fly.\n\n```fsharp\nlet Config = new Options()\nConfig.Linkify <- true\n\nlet Md = new Remarkable()\nMd.Set(Config)\n```\n\n### Presets\n\nUse presets for quick setup:\n\n```fsharp\nlet MdCommonmark = new Remarkable(\"commonmark\") // strict commonmark mode\nlet MdFull = new Remarkable(\"full\") // enable all rules\n```\n\n### Syntax Highlighting\n\nSyntax highlighting for fenced code blocks can be applied using the `highlight` option.  \nRefer to the [original documentation](https://github.com/jonschlinkert/remarkable) for more.\n\n### Typographer\n\n```fsharp\nlet Config = new Options()\nConfig.Typographer <- true\nlet Md = new Remarkable(Config)\n```\n\n**Replacements include**:\n\n- `''` â†’ `â€˜â€™`, `\"\"` â†’ `â€œâ€` (customizable)\n- `(c)` â†’ Â©, `(tm)` â†’ â„¢, `(r)` â†’ Â®\n- `+-` â†’ Â±, `(p)` â†’ Â§\n- `...` â†’ â€¦, `--` â†’ &ndash;, `---` â†’ &mdash;"
      },
      {
        "heading": "Differences from Original Library",
        "content": "The WebSharper extension is mostly the same as the original, with configuration exposed via the `Options` type whose fields can be directly set."
      }
    ]
  },
  {
    "filename": "websharper_remoting.md",
    "sections": [
      {
        "heading": "WebSharper Remoting",
        "content": "WebSharper supports **remote procedure calls (RPC)** from client-side (JavaScript) to server-side (ASP.NET or others). It is designed to be safe, efficient, and require minimal boilerplate."
      },
      {
        "heading": "Basic Example",
        "content": "```fsharp\nmodule Server =\n\n    [<Rpc>]\n    let GetBlogsByAuthor author =\n        use db = new DbContext()\n        async { return db.GetBlogsByAuthor author }\n\n[<JavaScript>]\nmodule Client =\n\n    let GetBlogsByAuthor (author: Author) (callback: Blog [] -> unit) =\n        async {\n            let! blogs = Server.GetBlogsByAuthor author\n            return callback blogs\n        } |> Async.Start\n```"
      },
      {
        "heading": "Key Assumptions",
        "content": "- Methods marked with `[<Rpc>]` are callable from the client.\n- Parameters and return types must be JSON-serializable.\n- Supports `Async<'T>` and synchronous calls.\n\n---"
      },
      {
        "heading": "Types Supported",
        "content": "Automatically serialized JSON types:\n\n- Primitives: `int`, `int64`, `float`, `string`, `bool`, `DateTime`\n- Collections: `'T[]`, `list`, `Map`, `Set`\n- Tuples: `'T1 * 'T2 * ...`\n- F# Unions, Records\n- Classes with a default constructor\n- Enums\n\n---"
      },
      {
        "heading": "RPC Call Modes",
        "content": "### 1. **Message-Passing (Unit return type)**\n\n```fsharp\n[<Remote>]\nlet Log (msg: string) =\n    Debug.WriteLine(\"MSG: {0}\", msg)\n```\n\nClient sends the request and does not wait for a response.\n\n---\n\n### 2. **Asynchronous Calls**\n\n```fsharp\n[<Remote>]\nlet Increment(x: int) = async { return x + 1 }\n\n[<JavaScript>]\nlet Foo (callback: int -> unit) =\n    async {\n        let! x = Increment 0\n        let! y = Increment x\n        let! z = Increment y\n        return callback z\n    } |> Async.Start\n```\n\n---\n\n### 3. **Synchronous Calls**\n\n```fsharp\n[<Remote>]\nlet Increase(x: int) = x + 1\n```\n\nNot recommended due to browser blocking.\n\n---"
      },
      {
        "heading": "Security",
        "content": "RPC endpoints are public; validate access inside the method:\n\n```fsharp\n[<Remote>]\nlet Login (user: string, password: string) =\n    let ctx = Web.Remoting.GetContext()\n    async {\n        let! verified = VerifyLogin(user, password)\n        if verified then\n            do! ctx.UserSession.LoginUser user\n            return true\n        else return false\n    }\n```\n\n---"
      },
      {
        "heading": "Server-Side Customization",
        "content": "Support for instance methods:\n\n```fsharp\ntype MyType() =\n    [<Remote>]\n    member this.MyMethod(...) = ...\n\nRemote<MyType>.MyMethod(...) // client-side call\n\n// Register the instance:\nWebSharper.Core.Remoting.AddHandler typeof<MyType> (new MyType())\n```\n\n---"
      },
      {
        "heading": "ASP.NET Core Support",
        "content": "Register handlers using:\n\n```fsharp\nservices.AddWebSharperRemoting<MyType>()\n```\n\n---"
      },
      {
        "heading": "Client-Side Customization",
        "content": "Change remoting URL globally:\n\n```fsharp\nWebSharper.Remoting.EndPoint <- \"https://api.example.com\"\n```\n\nCustomize behavior using `IRemotingProvider`:\n\n```fsharp\n[<JavaScript>]\ntype SafeProvider() =\n    inherit Remoting.AjaxRemotingProvider()\n\n    override this.Endpoint = \"https://api.example.com\"\n\n    override this.AsyncBase(handle, data) =\n        async {\n            try return! base.AsyncBase(handle, data)\n            with e ->\n                Console.Log(\"Error\", e)\n                return box None\n        }\n\n[<RemotingProvider(typeof<SafeProvider>)>]\n[<Remote>]\nlet SafeRemoteMethod() = ...\n```\n\nApply globally with an assembly attribute.\n\n---"
      },
      {
        "heading": "Communication Protocol",
        "content": "- Uses HTTP POST with `x-websharper-rpc` header.\n- Body contains JSON-encoded parameters.\n- URL defaults to current page but can be overridden."
      }
    ]
  },
  {
    "filename": "websharper_resources.md",
    "sections": [
      {
        "heading": "Managing Resource Dependencies",
        "content": "WebSharper automates the management of resource dependencies. For WebSharper, a **resource** is any HTML code rendered to the `<head>` section of a page (e.g. `<link>` for CSS or `<script>` for JavaScript). WebSharper infers the minimum set of required resources and the correct ordering."
      },
      {
        "heading": "Declaring Resources",
        "content": "Resources are typically defined as subclasses of `WebSharper.Core.Resources.BaseResource`:\n\n```fsharp\ntype R1() = inherit BaseResource(\"path.js\")\ntype R2() = inherit BaseResource(\"//cdn.net\", \"file1.js\", \"file2.js\")\n```\n\nMore complex resources can implement the `IResource` interface directly with a custom `Render` method.\n\nYou can also skip defining a subclass and use inline requirements:\n\n```fsharp\n[<Require(typeof<BaseResource>, \"path.js\")>]\n```"
      },
      {
        "heading": "Declaring Dependencies",
        "content": "- Annotate any type, member, or assembly with `[<Require(typeof<ResourceType>)>]` to include the resource.\n- Resources can require other resources by annotating their classes with `[<Require(...)]`."
      },
      {
        "heading": "Server-side Inclusion",
        "content": "If there is no client-side code, resources (like CSS) can be included using:\n\n```fsharp\nDoc.WebControl(new Web.Require<R1>())\n```\n\nThis adds the required resource to the page without rendering HTML at that location."
      },
      {
        "heading": "In WebSharper Interface Generator (WIG)",
        "content": "Declare resources using:\n\n```fsharp\nlet R1 = Resource \"ClassName\" \"file.js\"\nlet R2 = Resources \"ClassName2\" \"//cdn.net\" [\"f1.js\"; \"f2.js\"]\n```\n\nAdd them to the `Assembly` and declare usage with `Requires` or `RequiresExternal`."
      },
      {
        "heading": "Resource Resolution & Extraction",
        "content": "If a resource is embedded via:\n\n```fsharp\n[<assembly: WebSharper.WebResource(\"myfile.js\", \"mime/type\")>]\n```\n\nWebSharper will extract it to:\n\n- `/Scripts/WebSharper/` for JS\n- `/Content/WebSharper/` for CSS/other\n\nIf not embedded, the resource path must be an absolute or relative URL and WebSharper simply references it."
      },
      {
        "heading": "Hashing & Caching",
        "content": "A hash is computed and appended to the resource URL to avoid browser cache issues."
      },
      {
        "heading": "Resource URL Overrides",
        "content": "You can override a resource URL in your configuration:\n\nIn `appsettings.json`:\n\n```json\n\"WebSharper.JQuery.Resources.JQuery\": \"https://code.jquery.com/jquery-3.2.1.min.js\"\n```\n\nIn `Web.config`:\n\n```xml\n<add key=\"WebSharper.JQuery.Resources.JQuery\" value=\"https://code.jquery.com/jquery-3.2.1.min.js\" />\n```\n\nFor `IResource`-based resources, use `ctx.GetSetting(\"key\")` for custom config."
      },
      {
        "heading": "Using CDN",
        "content": "Enable CDN links for WebSharper core libraries by setting:\n\n```json\n\"WebSharper.StdlibUseCdn\": true\n```\n\nCustomize with:\n\n- `WebSharper.StdlibCdnFormat`\n- `WebSharper.CdnFormat.{AssemblyName}`"
      }
    ]
  },
  {
    "filename": "websharper_runtimeSettings.md",
    "sections": [
      {
        "heading": "WebSharper Runtime Settings",
        "content": "WebSharperâ€™s server-side runtime can be customized through configuration settings, depending on the project type."
      },
      {
        "heading": "Configuration Methods",
        "content": "### For .NET Core\n\nUse `Microsoft.Extensions.Configuration`, typically in a file called `appsettings.json` under the `websharper` key:\n\n```json\n{\n  \"websharper\": {\n    \"Setting1\": \"Value1\",\n    \"Setting2\": \"Value2\"\n  }\n}\n```\n\n### For .NET Framework\n\nUse `System.Configuration`:\n\n- `Web.config` for ASP.NET applications\n- `App.config` for standalone executables (copied to `YourApp.exe.config` on build)\n\nExample:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <appSettings>\n    <add key=\"Setting1\" value=\"Value1\" />\n    <add key=\"Setting2\" value=\"Value2\" />\n  </appSettings>\n</configuration>\n```"
      },
      {
        "heading": "Available Settings",
        "content": "### 1. Resource URL Overrides\n\nOverride resource URLs by setting the fully qualified name of the resource type as the key and the desired URL as the value.\n\nExample (for jQuery):\n\nIn `appsettings.json`:\n\n```json\n\"WebSharper.JQuery.Resources.JQuery\": \"https://code.jquery.com/jquery-3.2.1.min.js\"\n```\n\nIn `Web.config`:\n\n```xml\n<add key=\"WebSharper.JQuery.Resources.JQuery\" value=\"https://code.jquery.com/jquery-3.2.1.min.js\" />\n```\n\n> Nested types or modules use `+` instead of `.` in IL format.\n\nMore on Managing WebSharper Resources: https://developers.websharper.com/docs/v4.x/fs/resources\n\n### 2. CDN Settings\n\nUse CDN for WebSharper core libraries:\n\n- Enable:  \n  `WebSharper.StdlibUseCdn = true`\n\n- Default format:  \n  `//cdn.websharper.com/{assembly}/{version}/{filename}`\n\n- Override format:\n  - General: `WebSharper.StdlibCdnFormat`\n  - Per assembly: `WebSharper.CdnFormat.{assemblyname}`\n\n### 3. UseDownloadedResources\n\nIf your project uses external resources downloaded by the compiler (see:\nhttps://developers.websharper.com/docs/v4.x/fs/project-variables#downloadResources), then set:\n\n```json\n\"UseDownloadedResources\": true\n```\n\nThis instructs WebSharper to generate `<script>` and `<link>` tags pointing to the downloaded local copies."
      }
    ]
  },
  {
    "filename": "websharper_senchaTouch.md",
    "sections": [
      {
        "heading": "Sencha Touch WebSharper Extension",
        "content": "[Sencha Touch](http://www.sencha.com/products/touch/) is a leading HTML5+JavaScript framework for mobile application development. This matching WebSharper extension brings this powerful library in a type-safe manner to F#, enabling developers to author mobile web applications in pure F#."
      },
      {
        "heading": "Notes on Usage",
        "content": "This extension is auto-generated from the official Sencha Touch documentation, which may sometimes result in insufficient typing. You can work around this by using the `As<_>` primitive from WebSharper.\n\nRefer to the [official documentation](http://docs.sencha.com/touch/) for the full API.\n\nThis extension follows the same principles as [WebSharper Extensions for Ext JS](/extensions/ExtJS.md), with a few additions:\n\n### API Changes\n\n- `Ext.version` is renamed to `Ext.ExtVersion` to avoid naming conflicts.\n\n### Configuration Objects\n\nSencha components are created using `Ext.create`, which takes the class name and a config object. In WebSharper, config objects are represented as nested classes in `ExtCfg`.\n\nExample in JavaScript:\n\n```js\nExt.create(\"Ext.Container\", {\n  layout: fit,\n  fullscreen: true,\n}).show();\n```\n\nEquivalent F#:\n\n```fsharp\n(Ext.Create(\n    ExtCfg.Container(\n        Layout = \"fit\",\n        Fullscreen = true\n    )\n) |> As<Ext.Container>).Show()\n```\n\nTo avoid casting with `As`, use `.Create()` for type inference:\n\n```fsharp\nExtCfg.Container(\n    Layout = \"fit\",\n    Fullscreen = true\n).Create().Show()\n```\n\nTo extend configurations dynamically, use the `.With` method available on all config types.\n\nMixed arrays of config objects and components are supported via `As`."
      },
      {
        "heading": "Using Sencha Touch in WebSharper",
        "content": "Use a class inheriting from `Web.Control` in a sitelet:\n\n```fsharp\ntype AppControl() =\n    inherit Web.Control()\n\n    [<JavaScript>]\n    override this.Body =\n        Ext.Application(ExtParam.ApplicationConfig(Launch = As onLaunch))\n        upcast Div []\n```\n\nDefine `onLaunch` to set up your app container using `ExtCfg.Container` with `FullScreen = true`.\n\n### Adding Themes\n\nThe `senchatouch-all.js` file is included automatically. To add a theme, use a `Require` attribute:\n\n```fsharp\n[<Require(typeof<Resources.SenchaTouchCss>)>]\n```\n\nThis selects the desired CSS for your application."
      }
    ]
  },
  {
    "filename": "websharper_sitelets.md",
    "sections": [
      {
        "heading": "Routing requests and serving content with Sitelets",
        "content": "Sitelets are WebSharper's primary way to create server-side content. They provide facilities to route requests and generate HTML pages or JSON responses.\n\nSitelets allow you to:\n\n- Dynamically construct pages and serve arbitrary content.\n- Have full control of your URLs by specifying [custom routers](#advanced-sitelets) for linking them to content, or let the URLs be [automatically inferred](#sitelet-infer) from an endpoint type.\n- Compose contents into sitelets, which may themselves be [composed into larger sitelets](#sitelet-combinators).\n- Have [safe links](#linking) for referencing other content contained within your site.\n- Use the type-safe HTML and templating facilities from [UI](ui) on the server side.\n- Automatically [parse JSON requests and generate JSON responses](json) based on your types.\n\nBelow is a minimal example of a complete site serving one HTML page:\n\n    namespace SampleWebsite\n\n    open WebSharper.Sitelets\n\n    module SampleSite =\n        open WebSharper\n        open WebSharper.UI.Html\n        open WebSharper.UI.Server\n\n        type EndPoint =\n            | Index\n\n        let IndexContent context : Async<Content<EndPoint>> =\n            let time = System.DateTime.Now.ToString()\n            Content.Page(\n                Title = \"Index\",\n                Body = [h1 [] [text (\"Current time: \" + time)]]\n            )\n\n        [<Website>]\n        let MySampleWebsite : Sitelet<EndPoint> =\n            Sitelet.Content \"/index\" EndPoint.Index IndexContent\n\nFirst, a custom endpoint type is defined. It is used for linking requests to content within your sitelet. Here, you only need one endpoint, `EndPoint.Index`, corresponding to your only page.\n\nThe content of the index page is defined as a [`Content.Page`](/api/v4.1/WebSharper.UI.Server.Content#Page%60%601), where the body consists of a server side HTML element. Here the current time is computed and displayed within an `<h1>` tag.\n\nThe `MySampleWebsite` value has type [`Sitelet<EndPoint>`](/api/v4.1/WebSharper.Sitelets.Sitelet%601). It defines a complete website: the URL scheme, the `EndPoint` value corresponding to each served URL (only one in this case), and the content to serve for each endpoint. It uses the [`Sitelet.Content`](/api/v4.1/WebSharper.Sitelets.Sitelet#Content%60%601) operator to construct a sitelet for the Index endpoint, associating it with the `/index` URL and serving `IndexContent` as a response.\n\n`MySampleWebsite` is annotated with the attribute [`[<Website>]`](/api/v4.1/WebSharper.Sitelets.WebsiteAttribute) to indicate that this is the sitelet that should be served."
      },
      {
        "heading": "Routing",
        "content": "WebSharper Sitelets abstract away URLs and request parsing by using an endpoint type that represents the different HTTP endpoints available in a website. For example, a site's URL scheme can be represented by the following endpoint type:\n\n    type EndPoint =\n        | Index\n        | Stats of username: string\n        | BlogArticle of id: int * slug: string\n\nBased on this, a Sitelet is a value that represents the following mappings:\n\n- Mapping from requests to endpoints. A Sitelet is able to parse a URL such as `/blog/1243/some-article-slug` into the endpoint value `BlogArticle (id = 1243, slug = \"some-article-slug\")`. More advanced definitions can even parse query parameters, JSON bodies or posted forms.\n- Mapping from endpoints to URLs. This allows you to have internal links that are verified by the type system, instead of writing URLs by hand and being at the mercy of a typo or a change in the URL scheme. You can read more on this [in the \"Context\" section](#context).\n- Mapping from endpoints to content. Once a request has been parsed, this determines what content (HTML or other) must be returned to the client.\n\nA number of primitives are available to create and compose Sitelets.\n\n### Trivial Sitelets\n\nTwo helpers exist for creating a Sitelet with a trivial router: only handling requests on the root.\n\n- `Application.Text` takes just a `Context<_> -> string` function and creates a Sitelet that serves the result string as a text response.\n- `Application.SinglePage`takes a `Context<_> -> Async<Content<_>>` function and creates a Sitelet that serves the returned content.\n\n### Sitelet.Infer\n\nThe easiest way to create a more complex Sitelet is to automatically generate URLs from the shape of your endpoint type using [`Sitelet.Infer`](/api/v4.1/WebSharper.Sitelets.Sitelet#Infer%60%601), also aliased as [`Application.MultiPage`](/api/v4.1/WebSharper.Application#MultiPage%60%601). This function parses slash-separated path segments into the corresponding `EndPoint` value, and lets you match this endpoint and return the appropriate content. Here is an example sitelet using `Infer`:\n\n    namespace SampleWebsite\n\n    open WebSharper.Sitelets\n\n    module SampleSite =\n        open WebSharper\n        open WebSharper.UI.Html\n        open WebSharper.UI.Server\n\n        type EndPoint =\n            | Index\n            | Stats of username: string\n            | BlogArticle of id: int * slug: string\n\n        [<Website>]\n        let MyWebsite =\n            Sitelet.Infer <| fun context endpoint ->\n                match endpoint with\n                | Index ->\n                     // Content of the index page\n                     Content.Page(\n                         Title = \"Welcome!\",\n                         Body = [h1 [] [text \"Index page\"]])\n                | Stats username ->\n                     // Content of the stats page, which depends on the username\n                     Content.Page(\n                        Body = [text (\"Stats for \" + username)])\n                | BlogArticle (id, slug) ->\n                    // Content of the article page, which depends on id and slug\n                    Content.Page(\n                        Body = [text (sprintf \"Article id %i, slug %s\" id slug)])\n\nThe above sitelets accepts URLs with the following shape:\n\n    Accepted Request:    GET /Index\n    Parsed Endpoint:     Index\n    Returned Content:    <!DOCTYPE html>\n                         <html>\n                             <head><title>Welcome!</title></head>\n                             <body>\n                                 <h1>Index page</h1>\n                             </body>\n                         </html>\n\n    Accepted Request:    GET /Stats/someUser\n    Parsed Endpoint:     Stats (username = \"someUser\")\n    Returned Content:    <!DOCTYPE html>\n                         <html>\n                             <head></head>\n                             <body>\n                                 Stats for someUser\n                             </body>\n                         </html>\n\n    Accepted Request:    GET /BlogArticle/1423/some-article-slug\n    Parsed Endpoint:     BlogArticle (id = 1423, slug = \"some-article-slug\")\n    Returned Content:    <!DOCTYPE html>\n                         <html>\n                             <head></head>\n                             <body>\n                                 Article id 1423, slug some-article-slug\n                             </body>\n                         </html>\n\nThe following types are accepted by `Sitelet.Infer`:\n\n- Numbers and strings are encoded as a single path segment.\n\n      type EndPoint = string\n\n      // Accepted Request:    GET /abc\n      // Parsed Endpoint:     \"abc\"\n      // Returned Content:    (determined by Sitelet.Infer)\n\n      type EndPoint = int\n\n      // Accepted Request:    GET /1423\n      // Parsed Endpoint:     1423\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- Tuples and records are encoded as consecutive path segments.\n\n      type EndPoint = int * string\n\n      // Accepted Request:    GET /1/abc\n      // Parsed Endpoint:     (1, \"abc\")\n      // Returned Content:    (determined by Sitelet.Infer)\n\n      type EndPoint = { Number : int; Name : string }\n\n      // Accepted Request:    GET /1/abc\n      // Parsed Endpoint:     { Number = 1; Name = \"abc\" }\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- Union types are encoded as a path segment (or none or multiple) identifying the case, followed by segments for the arguments (see the example above).\n\n      type EndPoint = string option\n\n      // Accepted Request:    GET /Some/abc\n      // Parsed Endpoint:     Some \"abc\"\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    GET /None\n      // Parsed Endpoint:     None\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- Lists and arrays are encoded as a number representing the length, followed by each element. For example:\n\n      type EndPoint = string list\n\n      // Accepted Request:    GET /2/abc/def\n      // Parsed Endpoint:     [\"abc\"; \"def\"]\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- Enumerations are encoded as their underlying type.\n\n      type EndPoint = System.IO.FileAccess\n      // Accepted Request:    GET /3\n      // Parsed Endpoint:     System.IO.FileAccess.ReadWrite\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- `System.DateTime` is serialized with the format `yyyy-MM-dd-HH.mm.ss`. See below to customize this format.\n\n      type EndPoint = System.DateTime\n      // Accepted Request:    GET /2015-03-24-15.05.32\n      // Parsed Endpoint:     System.DateTime(2015,3,24,15,5,32)\n      // Returned Content:    (determined by Sitelet.Infer)\n\n### Customizing Sitelet.Infer\n\nIt is possible to annotate your endpoint type with attributes to customize `Sitelet.Infer`'s request inference. Here are the available attributes:\n\n- [`[<Method(\"GET\", \"POST\", ...)>]`](/api/v4.1/WebSharper.MethodAttribute) on a union case indicates which methods are parsed by this endpoint. Without this attribute, all methods are accepted.\n\n      type EndPoint =\n          | [<Method \"POST\">] PostArticle of id: int\n\n      // Accepted Request:    POST /PostArticle/12\n      // Parsed Endpoint:     PostArticle 12\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- [`[<EndPoint \"/string\">]`](/api/v4.1/WebSharper.EndPointAttribute) on a union case indicates the identifying segment.\n\n      type EndPoint =\n          | [<EndPoint \"/blog-article\">] BlogArticle of id: int * slug: string\n\n      // Accepted Request:    GET /blog-article/1423/some-article-slug\n      // Parsed Endpoint:     BlogArticle(id = 1423, slug = \"some-article-slug\")\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- `[<Method>]` and `[<EndPoint>]` can be combined in a single `[<EndPoint>]` attribute:\n\n      type EndPoint =\n          | [<EndPoint \"POST /article\">] PostArticle of id: int\n\n      // Accepted Request:    POST /article/12\n      // Parsed Endpoint:     PostArticle 12\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- A common trick is to use `[<EndPoint \"GET /\">]` on an argument-less union case to indicate the home page.\n\n      type EndPoint =\n          | [<EndPoint \"/\">] Home\n\n      // Accepted Request:    GET /\n      // Parsed Endpoint:     Home\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- If several cases have the same `EndPoint`, then parsing tries them in the order in which they are declared until one of them matches:\n\n      type EndPoint =\n        | [<EndPoint \"GET /blog\">] AllArticles\n        | [<EndPoint \"GET /blog\">] ArticleById of id: int\n        | [<EndPoint \"GET /blog\">] ArticleBySlug of slug: string\n\n      // Accepted Request:    GET /blog\n      // Parsed Endpoint:     AllArticles\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    GET /blog/123\n      // Parsed Endpoint:     ArticleById 123\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    GET /blog/my-article\n      // Parsed Endpoint:     ArticleBySlug \"my-article\"\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- The method of an endpoint can be specified in a field's type, rather than the main endpoint type itself:\n\n      type EndPoint =\n        | [<EndPoint \"GET /\">] Home\n        | [<EndPoint \"/api\">] Api of ApiEndPoint\n\n      and ApiEndPoint =\n        | [<EndPoint \"GET /article\">] GetArticle of int\n        | [<EndPoint \"POST /article\">] PostArticle of int\n\n      // Accepted Request:    GET /\n      // Parsed Endpoint:     Home\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    GET /api/article/123\n      // Parsed Endpoint:     Api (GetArticle 123)\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    POST /api/article/456\n      // Parsed Endpoint:     Api (PostArticle 456)\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- [`[<Query(\"arg1\", \"arg2\", ...)>]`](/api/v4.1/WebSharper.QueryAttribute) on a union case indicates that the fields with the given names must be parsed as GET query parameters instead of path segments. The value of this field must be either a base type (number, string) or an option of a base type (in which case the parameter is optional).\n\n      type EndPoint =\n          | [<Query(\"id\", \"slug\")>] BlogArticle of id: int * slug: string option\n\n      // Accepted Request:    GET /BlogArticle?id=1423&slug=some-article-slug\n      // Parsed Endpoint:     BlogArticle(id = 1423, slug = Some \"some-article-slug\")\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    GET /BlogArticle?id=1423\n      // Parsed Endpoint:     BlogArticle(id = 1423, slug = None)\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- You can of course mix Query and non-Query parameters.\n\n      type EndPoint =\n          | [<Query(\"slug\")>] BlogArticle of id: int * slug: string option\n\n      // Accepted Request:    GET /BlogArticle/1423?slug=some-article-slug\n      // Parsed Endpoint:     BlogArticle(id = 1423, slug = Some \"some-article-slug\")\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- Similarly, `[<Query>]` on a record field indicates that this field must be parsed as a GET query parameter.\n\n      type EndPoint =\n          {\n              id : int\n              [<Query>] slug : string option\n          }\n\n      // Accepted Request:    GET /1423?slug=some-article-slug\n      // Parsed Endpoint:     { id = 1423; slug = Some \"some-article-slug\" }\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- [`[<Json \"arg\">]`](/api/v4.1/WebSharper.JsonAttribute) on a union case indicates that the field with the given name must be parsed as JSON from the body of the request. If an endpoint type contains several `[<Json>]` fields, a runtime error is thrown.\n\n  [Learn more about JSON parsing.](json)\n\n      type EndPoint =\n          | [<Method \"POST\"; Json \"data\">] PostBlog of id: int * data: BlogData\n      and BlogData =\n          {\n              slug: string\n              title: string\n          }\n\n      // Accepted Request:    POST /PostBlog/1423\n      //\n      //                      {\"slug\": \"some-blog-post\", \"title\": \"Some blog post!\"}\n      //\n      // Parsed Endpoint:     PostBlog(\n      //                          id = 1423,\n      //                          data = { slug = \"some-blog-post\"\n      //                                   title = \"Some blog post!\" })\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- Similarly, `[<Json>]` on a record field indicates that this field must be parsed as JSON from the body of the request.\n\n      type EndPoint =\n          | [<Method \"POST\">] PostBlog of BlogPostArgs\n      and BlogPostArgs =\n          {\n              id: int\n              [<Json>] data: BlogData\n          }\n      and BlogData =\n          {\n              slug: string\n              title: string\n          }\n\n      // Accepted Request:    POST /PostBlog/1423\n      //\n      //                      {\"slug\": \"some-blog-post\", \"title\": \"Some blog post!\"}\n      //\n      // Parsed Endpoint:     PostBlog { id = 1423,\n      //                                 data = { slug = \"some-blog-post\"\n      //                                          title = \"Some blog post!\" } }\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- [`[<FormData(\"arg1\", \"arg2\", ...)>]`](/api/v4.1/WebSharper.FormDataAttribute) on a union case indicates that the fields with the given names must be parsed from the body as form data (`application/x-www-form-urlencoded` or `multipart/form-data`) instead of path segments. The value of this field must be either a base type (number, string) or an option of a base type (in which case the parameter is optional).\n\n      type EndPoint =\n          | [<FormData(\"id\", \"slug\")>] BlogArticle of id: int * slug: string option\n\n      // Accepted Request:    POST /BlogArticle\n      //                      Content-Type: application/x-www-form-urlencoded\n      //\n      //                      id=1423&slug=some-article-slug\n      //\n      // Parsed Endpoint:     BlogArticle(id = 1423, slug = Some \"some-article-slug\")\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    POST /BlogArticle\n      //                      Content-Type: application/x-www-form-urlencoded\n      //\n      //                      id=1423\n      //\n      // Parsed Endpoint:     BlogArticle(id = 1423, slug = None)\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- Similarly, `[<FormData>]` on a record field indicates that this field must be parsed from the body as form data.\n\n      type EndPoint =\n          {\n              id : int\n              [<FormData>] slug : string option\n          }\n\n      // Accepted Request:    POST /1423\n      //                      Content-Type: application/x-www-form-urlencoded\n      //\n      //                      slug=some-article-slug\n      //\n      // Parsed Endpoint:     { id = 1423; slug = Some \"some-article-slug\" }\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- [`[<DateTimeFormat(string)>]`](/api/v4.1/WebSharper.DateTimeFormatAttribute) on a record field or named union case field of type `System.DateTime` indicates the date format to use. Be careful as some characters are not valid in URLs; in particular, the ISO 8601 round-trip format (`\"o\"` format) cannot be used because it uses the character `:`.\n\n      type EndPoint =\n          {\n              [<DateTimeFormat \"yyyy-MM-dd\">] dateOnly: System.DateTime\n          }\n\n      // Accepted Request:    GET /2015-03-24\n      // Parsed Endpoint:     System.DateTime(2015,3,24)\n      // Returned Content:    (determined by Sitelet.Infer)\n\n      type EndPoint =\n          | [<DateTimeFormat(\"time\", \"HH.mm.ss\")>] A of time: System.DateTime\n\n      // Accepted Request:    GET /A/15.05.32\n      // Parsed Endpoint:     A (System.DateTime(2015,3,24,15,5,32))\n      // Returned Content:    (determined by Sitelet.Infer)\n\n- [`[<Wildcard>]`](/api/v4.1/WebSharper.WildcardAttribute) on a union case indicates that the last argument represents the remainder of the url's path. That argument can be a `list<'T>`, a `'T[]`, or a `string`.\n\n      type EndPoint =\n          | [<Wildcard>] Articles of pageId: int * tags: list<string>\n          | [<Wildcard>] Articles2 of (int * string)[]\n          | [<Wildcard>] GetFile of path: string\n\n      // Accepted Request:    GET /Articles/123/fsharp/websharper\n      // Parsed Endpoint:     Articles(123, [\"fsharp\"; \"websharper\"])\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    GET /Articles2/123/fsharp/456/websharper\n      // Parsed Endpoint:     Articles2 [(123, \"fsharp\"); (456, \"websharper\")]\n      // Returned Content:    (determined by Sitelet.Infer)\n      //\n      // Accepted Request:    GET /GetFile/css/main.css\n      // Parsed Endpoint:     GetFile \"css/main.css\"\n      // Returned Content:    (determined by Sitelet.Infer)\n\n### Catching wrong requests with Sitelet.InferWithErrors\n\nBy default, `Sitelet.Infer` ignores requests that it fails to parse, in order to give potential other components (such as [ASP.NET](http://websharper.com/docs/aspnet)) a chance to respond to the request. However, if you want to send a custom response for badly-formatted requests, you can use [`Sitelet.InferWithErrors`](/api/v4.1/WebSharper.Sitelets.Sitelet#InferWithErrors%60%601) instead. This function wraps the parsed request in the [`ParseRequestResult<'EndPoint>`](/api/v4.1/WebSharper.Sitelets.ParseRequestResult%601) union. Here are the cases you can match against:\n\n- `ParseRequestResult.Success of 'EndPoint`: The request was successfully parsed.\n- `ParseRequestResult.InvalidMethod of 'EndPoint * method: string`: An endpoint was successfully parsed but with the given wrong HTTP method.\n- `ParseRequestResult.MissingQueryParameter of 'EndPoint * name: string`: The URL path was successfully parsed but a mandatory query parameter with the given name was missing. The endpoint value contains a default value (`Unchecked.defaultof<_>`) where the query parameter value should be.\n- `ParseRequestResult.InvalidJson of 'EndPoint`: The URL was successfully parsed but the JSON body wasn't. The endpoint value contains a default value (`Unchecked.defaultof<_>`) where the JSON-decoded value should be.\n- `ParseRequestResult.MissingFormData of 'EndPoint * name: string`: The URL was successfully parsed but a form data parameter with the given name was missing or wrongly formatted. The endpoint value contains a default value ([`Unchecked.defaultof<_>`](/api/v4.1/Microsoft.FSharp.Core.Operators.Unchecked#defaultof%60%601)) where the form body-decoded value should be.\n\nIf multiple of these kinds of errors happen, only the last one is reported.\n\nIf the URL path isn't matched, then the request falls through as with `Sitelet.Infer`.\n\n    open WebSharper.Sitelets\n\n    module SampleSite =\n        open WebSharper.Sitelets\n\n        type EndPoint =\n        | [<Method \"GET\"; Query \"page\">] Articles of page: int\n\n        [<Website>]\n        let MySitelet = Sitelet.InferWithCustomErrors <| fun context endpoint ->\n            match endpoint with\n            | ParseRequestResult.Success (Articles page) ->\n                Content.Text (\"serving page \" + string page)\n            | ParseRequestResult.InvalidMethod (_, m) ->\n                Content.Text (\"Invalid method: \" + m)\n                |> Content.SetStatus Http.Status.MethodNotAllowed\n            | ParseRequestResult.MissingQueryParameter (_, p) ->\n                Content.Text (\"Missing parameter: \" + p)\n                |> Content.SetStatus (Http.Status.Custom 400 (Some \"Bad Request\"))\n            | _ ->\n                Content.Text \"We don't have JSON or FormData, so this shouldn't happen\"\n                |> Content.SetStatus Http.Status.InternalServerError\n\n    // Accepted Request:    GET /Articles?page=123\n    // Parsed Endpoint:     Articles 123\n    // Returned Content:    200 Ok\n    //                      serving page 123\n    //\n    // Accepted Request:    POST /Articles?page=123\n    // Parsed Endpoint:     InvalidMethod(Articles 123, \"POST\")\n    // Returned Content:    405 Method Not Allowed\n    //                      Invalid method: POST\n    //\n    // Accepted Request:    GET /Articles\n    // Parsed Endpoint:     MissingQueryParameter(Articles 0, \"page\")\n    // Returned Content:    400 Bad Request\n    //                      Missing parameter: page\n    //\n    // Request:             GET /this-path-doesnt-exist\n    // Parsed Endpoint:     (none)\n    // Returned Content:    (not found page provided by the host)\n\n### Other Constructors and Combinators\n\nThe following functions are available to build simple sitelets or compose more complex sitelets out of simple ones:\n\n- [`Sitelet.Empty`](/api/v4.1/WebSharper.Sitelets.Sitelet#Empty%60%601) creates a Sitelet which does not recognize any URLs.\n- [`Sitelet.Content`](/api/v4.1/WebSharper.Sitelets.Sitelet.Content%60%601), as shown in the first example, builds a sitelet that accepts a single URL and maps it to a given endpoint and content.\n\n      Sitelet.Content \"/index\" Index IndexContent\n\n      // Accepted Request:    GET /index\n      // Parsed Endpoint:     Index\n      // Returned Content:    (value of IndexContent : Content<EndPoint>)\n\n- [`Sitelet.Sum`](/api/v4.1/WebSharper.Sitelets.Sitelet.Sum%60%601) takes a sequence of Sitelets and tries them in order until one of them accepts the URL. It is generally used to combine a list of `Sitelet.Content`s.\n\n  The following sitelet accepts `/index` and `/about`:\n\n      Sitelet.Sum [\n          Sitelet.Content \"/index\" Index IndexContent\n          Sitelet.Content \"/about\" About AboutContent\n      ]\n\n      // Accepted Request:    GET /index\n      // Parsed Endpoint:     Index\n      // Returned Content:    (value of IndexContent : Content<EndPoint>)\n      //\n      // Accepted Request:    GET /about\n      // Parsed Endpoint:     About\n      // Returned Content:    (value of AboutContent : Content<EndPoint>)\n\n- [`+`](/api/v4.1/WebSharper.Sitelets.Sitelet%601#op_LessBarGreater%60%601) takes two Sitelets and tries them in order. `s1 + s2` is equivalent to `Sitelet.Sum [s1; s2]`.\n\n      Sitelet.Content \"/index\" Index IndexContent\n      +\n      Sitelet.Content \"/about\" About AboutContent\n\n      // Same as above.\n\nFor the mathematically enclined, the functions `Sitelet.Empty` and `+` make sitelets a monoid. Note that it is non-commutative: if a URL is accepted by both sitelets, the left one will be chosen to handle the request.\n\n- [`Sitelet.Shift`](/api/v4.1/WebSharper.Sitelets.Sitelet#Shift%60%601) takes a Sitelet and shifts it by a path segment.\n\n      Sitelet.Content \"index\" Index IndexContent\n      |> Sitelet.Shift \"folder\"\n\n      // Accepted Request:    GET /folder/index\n      // Parsed Endpoint:     Index\n      // Returned Content:    (value of IndexContent : Content<EndPoint>)\n\n- [`Sitelet.Folder`](/api/v4.1/WebSharper.Sitelets.Sitelet#Folder%60%601) takes a sequence of Sitelets and shifts them by a path segment. It is effectively a combination of `Sum` and `Shift`.\n\n      Sitelet.Folder \"folder\" [\n          Sitelet.Content \"/index\" Index IndexContent\n          Sitelet.Content \"/about\" About AboutContent\n      ]\n\n      // Accepted Request:    GET /folder/index\n      // Parsed Endpoint:     Index\n      // Returned Content:    (value of IndexContent : Content<EndPoint>)\n      //\n      // Accepted Request:    GET /folder/about\n      // Parsed Endpoint:     About\n      // Returned Content:    (value of AboutContent : Content<EndPoint>)\n\n- [`Sitelet.Protect`](/api/v4.1/WebSharper.Sitelets.Sitelet#Protect%60%601) creates protected content, i.e. content only available for authenticated users:\n\n      module Sitelet =\n          type Filter<'EndPoint> =\n              {\n                  VerifyUser : string -> bool;\n                  LoginRedirect : 'EndPoint -> 'EndPoint\n              }\n\n      val Protect : Filter<'EndPoint> -> Sitelet<'EndPoint> -> Sitelet<'EndPoint>\n\n  Given a filter value and a sitelet, `Protect` returns a new sitelet that requires a logged in user that passes the `VerifyUser` predicate, specified by the filter. If the user is not logged in, or the predicate returns false, the request is redirected to the endpoint specified by the `LoginRedirect` function specified by the filter. [See here how to log users in and out.](#context)\n\n- [`Sitelet.Map`](/api/v4.1/WebSharper.Sitelets.Sitelet#Map%60%602) converts a Sitelet to a different endpoint type using mapping functions in both directions.\n\n      type EndPoint = Article of string\n\n      let s : Sitelet<string> = Sitelet.Infer sContent\n\n      let s2 : Sitelet<EndPoint> = Sitelet.Map Article (fun (Article a) -> a) s\n\n- [`Sitelet.Embed`](/api/v4.1/WebSharper.Sitelets.Sitelet#Embed%60%602) similarly converts a Sitelet to a different endpoint type, but with a partial mapping function: the input endpoint type represents only a subset of the result endpoint type.\n\n      type EndPoint =\n          | Index\n          | Article of string\n\n      let index : Sitelet<EndPoint> = Sitelet.Content \"/\" Index indexContent\n      let article : Sitelet<string> = Sitelet.Infer articleContent\n      let fullSitelet =\n          Sitelet.Sum [\n              index\n              article |> Sitelet.Embed Article (function Article a -> Some a | _ -> None)\n          ]\n\n- [`Sitelet.EmbedInUnion`](/api/v4.1/WebSharper.Sitelets.Sitelet#EmbedInUnion%60%602) is a simpler version of `Sitelet.Embed` when the mapping function is a union case constructor.\n\n      type EndPoint =\n          | Index\n          | Article of string\n\n      let index : Sitelet<EndPoint> = Sitelet.Content \"/\" Index indexContent\n      let article : Sitelet<string> = Sitelet.Infer articleContent\n      let fullSitelet =\n          Sitelet.Sum [\n              index\n              article |> Sitelet.EmbedInUnion <@ Article @>\n          ]\n\n- [`Sitelet.InferPartial`](/api/v4.1/WebSharper.Sitelets.Sitelet#InferPartial%60%602) is equivalent to combining `Sitelet.Infer` and `Sitelet.Embed`, except the context passed to the infer function is of the outer endpoint type instead of the inner. For example, in the example for `Sitelet.Embed` above, the function `articleContent` receives a `Context<string>` and can therefore only create links to articles. Whereas with `InferPartial`, it receives a full `Context<EndPoint>` and can create links to `Index`.\n\n      type EndPoint =\n          | Index\n          | Article of string\n\n      let index : Sitelet<EndPoint> = Sitelet.Content \"/\" Index indexContent\n      let article : Sitelet<EndPoint> =\n          Sitelet.InferPartial Article (function Article a -> Some a | _ -> None) articleContent\n      let fullSitelet = Sitelet.Sum [ index; article ]\n\n- [`Sitelet.InferPartialInUnion`](/api/v4.1/WebSharper.Sitelets.Sitelet#InferPartialInUnion%60%602) is a simpler version of `Sitelet.InferPartial` when the mapping function is a union case constructor.\n\n      type EndPoint =\n          | Index\n          | Article of string\n\n      let index : Sitelet<EndPoint> = Sitelet.Content \"/\" Index indexContent\n      let article : Sitelet<EndPoint> = Sitelet.InferPartialInUnion <@ Article @> articleContent\n      let fullSitelet = Sitelet.Sum [ index; article ]"
      },
      {
        "heading": "Content",
        "content": "Content describes the response to send back to the client: its HTTP status, headers and body. Content is always worked with asynchronously: all the constructors and combinators described below take and return values of type `Async<Content<'EndPoint>>`. You will find various functions that create different types of content: ordinary text (`Content.Text`), file content (`Content.File`), HTML (`Content.Page`), HTML based on templates (`Content.WithTemplate`), JSON (`Content.Json`), custom content (`Content.Custom`), and HTTP error codes and redirects.\n\n### Content.Text\n\nThe simplest response is plain text content, created by passing a string to [`Content.Text`](/api/v4.1/WebSharper.Sitelets.Content#Text%60%601).\n\n    let simpleResponse =\n        Content.Text \"This is the response body.\"\n\n### Content.File\n\nYou can serve files using [`Content.File`](/api/v4.1/WebSharper.Sitelets.Content#File%60%601). Optionally, you can set the content type returned for the file response and whether file access is allowed outside of the web root:\n\n    type EndPoint = //. . .\n\n    let fileResponse: Async<Content<EndPoint>> =\n        Content.File(\"../Main.fs\", AllowOutsideRootFolder=true, ContentType=\"text/plain\")\n\n### Content.Page\n\nYou can return full HTML pages, with managed dependencies using [`Content.Page`](/api/v4.1/WebSharper.UI.Next.Server.Content#Page%60%601). Here is a simple example:\n\n    open WebSharper.UI.Html\n\n    let IndexPage : Async<Content<EndPoint>> =\n        Content.Page(\n            Title = \"Welcome!\",\n            Head = [ link [attr.href \"/css/style.css\"; attr.rel \"stylesheet\"] [] ],\n            Body = [\n                h1 [] [text \"Welcome to my site.\"]\n            ]\n        )\n\nThe optional named arguments `Title`, `Head`, `Body` and `Doctype` set the corresponding elements of the HTML page. To learn how to create HTML elements for `Head` and `Body`, see [the HTML combinators documentation](HtmlCombinators.md).\n\n### Content.WithTemplate\n\nVery often, most of a page is constant, and only parts of it need to be generated. Templates allow you to use a static HTML file for the main structure, with placeholders for generated content. [See here for more information about templates.](Templates.md)\n\n### Content.Json\n\nIf you are creating a web API, then Sitelets can automatically generate JSON content for you based on the type of your data. Simply pass your value to [`Content.Json`](/api/v4.1/WebSharper.Sitelets.Content#Json%60%601), and WebSharper will serialize it. The format is the same as when parsing requests. [See here for more information about the JSON format.](json)\n\n    type BlogArticleResponse =\n        {\n            id: int\n            slug: string\n            title: string\n        }\n\n    let content id =\n        Content.Json\n            {\n                id = id\n                slug = \"some-blog-article\"\n                title = \"Some blog article!\"\n            }\n\n    type EndPoint =\n        | GetBlogArticle of id: int\n\n    let sitelet = Sitelet.Infer <| fun context endpoint ->\n        match endpoint with\n        | GetBlogArticle id -> content id\n\n    // Accepted Request:    GET /GetBlogArticle/1423\n    // Parsed Endpoint:     GetBlogArticle 1423\n    // Returned Content:    {\"id\": 1423, \"slug\": \"some-blog-article\", \"title\": \"Some blog article!\"}\n\n### Content.Custom\n\n[`Content.Custom`](/api/v4.1/WebSharper.Sitelets.Content#Custom%60%601) can be used to output any type of content. It takes three optional named arguments that corresponds to the aforementioned elements of the response:\n\n- `Status` is the HTTP status code. It can be created using the function [`Http.Status.Custom`](/api/v4.1/WebSharper.Sitelets.Http.Status#Custom), or you can use one of the predefined statuses such as [`Http.Status.Forbidden`](/api/v4.1/WebSharper.Sitelets.Http.Status#Forbidden).\n- `Headers` is the HTTP headers. You can create them using the function [`Http.Header.Custom`](/api/v4.1/WebSharper.Sitelets.Http.Header#Custom).\n- `WriteBody` writes the response body.\n\n  let content =\n  Content.Custom(\n  Status = Http.Status.Ok,\n  Headers = [Http.Header.Custom \"Content-Type\" \"text/plain\"],\n  WriteBody = fun stream ->\n  use w = new System.IO.StreamWriter(stream)\n  w.Write(\"The contents of the text file.\")\n  )\n\n  type EndPoint =\n  | GetSomeTextFile\n\n  let sitelet = Sitelet.Content \"/someTextFile.txt\" GetSomeTextFile content\n\n  // Accepted Request: GET /someTextFile.txt\n  // Parsed Endpoint: GetSomeTextFile\n  // Returned Content: The contents of the text file.\n\n### Helpers\n\nIn addition to the four standard Content families above, the [`Content`](/api/v4.1/WebSharper.Sitelets.Content) module contains a few helper functions.\n\n- Redirection:\n\n      module Content =\n          /// Permanently redirect to an endpoint. (HTTP status code 301)\n          val RedirectPermanent : 'EndPoint -> Async<Content<'EndPoint>>\n          /// Permanently redirect to a URL. (HTTP status code 301)\n          val RedirectPermanentToUrl : string -> Async<Content<'EndPoint>>\n          /// Temporarily redirect to an endpoint. (HTTP status code 307)\n          val RedirectTemporary : 'EndPoint -> Async<Content<'EndPoint>>\n          /// Temporarily redirect to a URL. (HTTP status code 307)\n          val RedirectTemporaryToUrl : string -> Async<Content<'EndPoint>>\n\n- Response mapping: if you want to return HTML or JSON content, but further customize the HTTP response, then you can use one of the following:\n\n      module Content =\n          /// Set the HTTP status of a response.\n          val SetStatus : Http.Status -> Async<Content<'T>> -> Async<Content<'T>>\n          /// Add headers to a response.\n          val WithHeaders : seq<Header> -> Async<Content<'T>> -> Async<Content<'T>>\n          /// Replace the headers of a response.\n          val SetHeaders : seq<Header> -> Async<Content<'T>> -> Async<Content<'T>>\n\n      // Example use\n      let customForbidden =\n          Content.Page(\n              Title = \"No entrance!\",\n              Body = [text \"Oops! You're not supposed to be here.\"]\n          )\n          // Set the HTTP status code to 403 Forbidden:\n          |> Content.SetStatus Http.Status.Forbidden\n          // Add an HTTP header:\n          |> Content.WithHeaders [Http.Header.Custom \"Content-Language\" \"en\"]"
      },
      {
        "heading": "Using the Context",
        "content": "The functions to create sitelets from content, namely `Sitelet.Infer` and `Sitelet.Content`, provide a context of type [`Context<'T>`](/api/v4.1/WebSharper.Sitelets.Context%601). This context can be used for several purposes; the most important are creating internal links and managing user sessions.\n\n### Creating links\n\nSince every accepted URL is uniquely mapped to a strongly typed endpoint value, it is also possible to generate internal links from an endpoint value. For this, you can use the method [`context.Link`](/api/v4.1/WebSharper.Sitelets.Context%601#Link).\n\n    open WebSharper.UI.Html\n\n    type EndPoint = | BlogArticle of id:int * slug:string\n\n    let HomePage (context: Context<EndPoint>) =\n        Content.Page(\n            Title = \"Welcome!\",\n            Body = [\n                h1 [] [text \"Index page\"]\n                a [attr.href (context.Link (BlogArticle(1423, \"some-article-slug\")))] [\n                    text \"Go to some article\"\n                ]\n                br [] []\n                a [attr.href (context.ResolveUrl \"~/Page2.html\")] [\n                    text \"Go to page 2\"\n                ]\n            ]\n        )\n\nNote how `context.Link` is used in order to resolve the URL to the `BlogArticle` endpoint. Endpoint URLs are always constructed relative to the application root, whether the application is deployed as a standalone website or in a virtual folder. [`context.ResolveUrl`](/api/v4.1/WebSharper.Sitelets.Context%601#ResolveUrl) helps to manually construct application-relative URLs to resources that do not map to endpoints.\n\n### Managing User Sessions\n\n`Context<'T>` can be used to access the currently logged in user. The member [`UserSession`](/api/v4.1/WebSharper.Sitelets.Context%601#UserSession) has the following members:\n\n- [`LoginUser : username: string * ?persistent: bool -> Async<unit>`](/api/v4.1/WebSharper.Web.IUserSession#LoginUser)  \n  [`LoginUser : username: string * duration: System.TimeSpan -> Async<unit>`](/api/v4.1/WebSharper.Web.IUserSession#LoginUser)\n\n  Logs in the user with the given username. This sets a cookie that is uniquely associated with this username. The second parameter determines the expiration of the login:\n\n  - `LoginUser(\"username\")` creates a cookie that expires with the user's browser session.\n  - `LoginUser(\"username\", persistent = true)` creates a cookie that lasts indefinitely.\n  - `LoginUser(\"username\", duration = d)` creates a cookie that expires after the given duration.\n\n  Example:\n\n      let LoggedInPage (context: Context<EndPoint>) (username: string) =\n          async {\n              // We're assuming here that the login is successful,\n              // eg you have verified a password against a database.\n              do! context.UserSession.LoginUser(username,\n                      duration = System.TimeSpan.FromDays(30.))\n              return! Content.Page(\n                  Title = \"Welcome!\",\n                  Body = [ text (sprintf \"Welcome, %s!\" username) ]\n              )\n          }\n\n- [`GetLoggedInUser : unit -> Async<string option>`](/api/v4.1/WebSharper.Web.IUserSession#GetLoggedInUser)\n\n  Retrieves the currently logged in user's username, or `None` if the user is not logged in.\n\n  Example:\n\n      let HomePage (context: Context<EndPoint>) =\n          async {\n              let! username = context.UserSession.GetLoggedInUser()\n              return! Content.Page(\n                  Title = \"Welcome!\",\n                  Body = [\n                      text (\n                          match username with\n                          | None -> \"Welcome, stranger!\"\n                          | Some u -> sprintf \"Welcome back, %s!\" u\n                      )\n                  ]\n              )\n          }\n\n- [`Logout : unit -> unit`](/api/v4.1/WebSharper.Web.IUserSession#Logout)\n\n  Logs the user out.\n\n  Example:\n\n      let Logout (context: Context<EndPoint>) =\n          async {\n              do! context.UserSession.Logout()\n              return! Content.RedirectTemporary Home\n          }\n\nThe implementation of these functions relies on cookies and thus requires that the browser has enabled cookies.\n\n### Other Context members\n\n`WebSharper.Sitelets.Context<'T>` inherits from `WebSharper.Web.Context`, and a number of properties and methods from it are useful. [See the documentation for `WebSharper.Web.Context`](web-context)."
      },
      {
        "heading": "Advanced Sitelets",
        "content": "So far, we have constructed sitelets using built-in constructors such as `Sitelet.Infer`. But if you want finer-grained control over the exact URLs that it parses and generates, you can create sitelets by hand.\n\nA sitelet consists of two parts; a router and a handler. The job of the router is to map endpoints to URLs and to map HTTP requests to endpoints. The handler is responsible for handling endpoints, by returning content (a synchronous or asynchronous HTTP response).\n\n### Routers\n\nThe router component of a sitelet can be constructed in multiple ways. The main options are:\n\n- Declaratively, using `Router.Infer` which is also used internally by `Sitelets.Infer`. The main advantage of creating a router value separately, is that you can add a `[<JavaScript>]` attribute on it, so that the client can generate links from endpoint values too. `WebSharper.UI` contains functionality for client-side routing too, making it possible to handle all or a subset of internal links without browser navigation. Sharing the router abstraction between client and server means that server can generate links that the client will handle and vice versa.\n- Manually, by using combinators to build up larger routers from elementary `Router` values or inferred ones. You can use this to further customize routing logic if you want an URL schema that is not fitting default inferred URL shapes, or add additional URLs to handle (e. g. for keeping compatibility with old links).\n- Implementing the `IRouter` interface directly or using the `Router.New` helper. This is the most universal way, but has less options for composition.\n\nThe following example shows how you can create a router of type `WebSharper.Sitelets.IRouter<EndPoint>` by writing the two mappings manually:\n\n    open WebSharper.Sitelets\n\n    module WebSite =\n        type EndPoint = | Page1 | Page2\n\n        let MyRouter : Router<EndPoint> =\n            let route (req: Http.Request) =\n                if req.Uri.LocalPath = \"/page1\" then\n                    Some Page1\n                elif req.Uri.LocalPath = \"/page2\" then\n                    Some Page2\n                else\n                    None\n            let link endPoint =\n                match endPoint with\n                | EndPoint.Page1 ->\n                    Some <| System.Uri(\"/page1\", System.UriKind.Relative)\n                | EndPoint.Page2 ->\n                    Some <| System.Uri(\"/page2\", System.UriKind.Relative)\n            Router.New route link\n\nA simplified version, `Router.Create` exists to create routers, using only already broken up URL segments:\n\n    open WebSharper.Sitelets\n\n    module WebSite =\n        type EndPoint = | Page1 | Page2\n\n        let MyRouter : Router<EndPoint> =\n            let link endPoint =\n                match endPoint with\n                | Page1 -> [ \"page1\" ]\n                | Page2 -> [ \"page2\" ]\n            let route path =\n                match path with\n                | [ \"page1\" ] -> Some Page1\n                | [ \"page2\" ] -> Some Page2\n                | _ -> None\n            Router.Create link route\n\nSpecifying routers manually gives you full control of how to parse incoming requests and to map endpoints to corresponding URLs. It is your responsibility to make sure that the router forms a bijection of URLs and endpoints, so that linking to an endpoint produces a URL that is in turn routed back to the same endpoint.\n\nConstructing routers manually is only required for very special cases. The above router can for example be generated using [`Router.Table`](/api/v4.1/WebSharper.Sitelets.Router#Table%60%601):\n\n    let MyRouter : Router<EndPoint> =\n        [\n            EndPoint.Page1, \"/page1\"\n            EndPoint.Page2, \"/page2\"\n        ]\n        |> Router.Table\n\nEven simpler, if you want to create the same URL shapes that would be generated by `Sitelet.Infer`, you can simply use [`Router.Infer()`](/api/v4.1/WebSharper.Sitelets.Router#Infer%60%601):\n\n    let MyRouter : Router<EndPoint> =\n        Router.Infer ()\n\n### Router primitives\n\nThe `WebSharper.Sitelets.RouterOperators` module exposes the following basic `Router` values and construct functions:\n\n- `rRoot`: Recognizes and writes an empty path.\n- `r \"path\"`: Recognizes and writes a specific subpath. You can also write `r \"path/subpath\"` to parse two or more segments of the URL.\n- `rString`, `rChar`: Recognizes a URIComponent as a string or char and writes it as a URIComponent.\n- `rTryParse<'T>`: Creates a router for any type that defines a `TryParse` static method.\n- `rInt`, `rDouble`, ...: Creates a router for numeric values.\n- `rBool`, `rGuid`: Additional primitive types to parse from or write to the URL.\n- `rDateTime`: Parse or write a `DateTime`, takes a format string.\n\n### Router combinators\n\n- `/` (alias `Router.Combine`): Parses or writes using two routers one after the other. For example `rString / rInt` will have type `Router<string * int>`. This operator has overloads for any combination of generic and non-generic routers, as well as a string on either side to add a constant URL fragment. For example `r \"article\" / r \"id\" / rInt` can be shortened to `\"article/id\" / rInt`.\n- `+` (alias `Router.Add`): Parses or writes using the first router if successful, otherwise the second.\n- `Router.Sum`: Optimized version of combining a sequence of routers with `+`. Parses or writes with the first router in the sequence that can handle the path or value.\n- `Router.Map`: A bijection (or just surjection) between representations handled by routers. For example if you have a `type Person = { Name: string; Age: int }`, then you can define a router for it by mapping from a `Router<string * int>` like so\n\n      let rPerson : Router<Person> =\n          rString / rInt\n          |> Router.Map\n              (fun (n, a) -> { Name = n; Age = a })\n              (fun p -> p.Name, p.Age)\n\n  See that `Map` needs two function arguments, to convert data back and forth between representations. All values of the resulting type must be mapped back to underlying type by the second function in a way compatible with the first function to work correctly.\n\n- `Router.MapTo`: Maps a non-generic `Router` to a single valued `Router<'T>`. For example if `Home` is a union case in your `Pages` union type describing pages on your site, you can create a router for it by:\n\n      let rHome : Router<Pages> =\n          rRoot |> Router.MapTo Home\n\n  This only needs a single value as argument, but the type used must be comparable, so the writer part of the newly created `Router<'T>` can decide if it is indeed a `Home` value that it needs to write by the underlying router (in our case producing a root URL).\n\n- `Router.Embed`: An injection between representations handled by routers. For example if you have a `Router<Person>` parsing a person's details, and a `Contact of Person` union case in your `Pages` union, you can do:\n\n      let rContact : Router<Pages> =\n          \"contact\" / rPerson\n          |> Router.Embed\n              Contact\n              (function Contact p -> Some p | _ -> None)\n\n  See that now we have two functions again, but the second is returning an option. The first tells us that once a path is parsed (for example we are recognizing `contact/Bob/32` here), it can wrap it in a `Contact` case (`Contact` here is used as a short version of a union case constructor, a function with signature `Person -> Pages`). And if the newly created router gets a value to write, it can use the second function to map it back optionally to an underlying value.\n\n- `Router.Filter`: restricts a router to parse/write values only that are passing a check. Usage: `rInt |> Router.Filter (fun x -> x >= 0)`, which won't parse and write negative values.\n- `Router.Slice`: restricts a router to parse/write values only that can be mapped to a new value. Equivalent to using `Filter` first to restrict the set of values and then `Map` to convert to a type that is a better representation of the restricted values.\n- `Router.TryMap`: a combination of `Slice` and `Embed`, a mapping from a subset of source values to a subset of target values. Both the encode and decode functions must return `None` if there is no mapping to a value of the other type.\n- `Router.Query`: Modifies a router to parse from and write to a specific query argument instead of main URL segments. Usage: `rInt |> Router.Query \"x\"`, which will read/write query segments like `?x=42`. You should pass only a router that is always reading/writing a single segment, which inclide primitive routers, `Router.Nullable`, and `Sum`s and `Map`s of these.\n- `Router.QueryOption`: Modifies a router to read an optional query value as an F# option. Creates a `Router<option<'T>>`, same restrictions apply as to `Query`.\n- `Router.QueryNullable`: Modifies a router to read an optional query value as a `System.Nullable`. Creates a `Router<Nullable<'T>>`, same restrictions apply as to `Query`.\n- `Router.Box`: Converts a `Router<'T>` to a `Router<obj>`. When writing, it uses a type check to see if the object is of type `'T` so it can be passed to underlying router.\n- `Router.Unbox`: Converts a `Router<obj>` to a `Router<'T>`. When parsing, it uses a type check to see if the object is of type `'T` so that the parsed value can be represented in `'T`.\n- `Router.Array`: Creates an array parser/writer. The URL will contain the length and then the items, so for example `Router.Array rString` can handle `2/x/y`.\n- `Router.List`: Creates a list parser/writer. Similar to `Router.Array`, just uses F# lists as data type.\n- `Router.Option`: Creates an F# option parser/writer. Writes or reads `None` and `Some/x` segments.\n- `Router.Nullable`: Creates a `Nullable` value parser/writer. Writes or reads `null` for null or a value that is handled by the input router. For\n- `Router.Infer`: Creates a router based on type shape. The attributes recognized are the same as `Sitelet.Infer` described in the [Sitelets documentation](sitelets).\n- `Router.Table`: Creates a router mapping between a list of static endpoint values and paths.\n- `Router.Method`: Creates a router that only parses request with the inner router, it the HTTP method methes the given method argument. By default, routers ignore the method.\n- `Router.Body` : Creates a router that parses and serializes any value to and from the request body with custom functions. If the will be used on server-side only to parse requests and generate links, the serialize function can return just a null or empty string. For example `Router.Body id id` just gets the request body as a string.\n- [`Router.Json`](/api/v4.1/WebSharper.Sitelets.Router#Json%60%601) creates a router that parses the request body by the JSON format derived from the type argument.\n- [`Router.FormData`](/api/v4.1/WebSharper.Sitelets.Router#FormData) creates a router from an underlying router handling query arguments that parses query arguments from the request body of a form post instead of the URL.\n- `Router.Delay` can be used to construct routers for recursive data types. Takes a `unit -> Router<'T>` function, and evaluates it firsthe t time the router is used for parsing and writing (never just when combining them).\n\n### Using the router\n\n- `Router.Link` creates a (relative) link using a router. A useful helper to have in the file defining your router is:\n\n          let Link page content =\n              a [ attr.href (Router.Link router page) ] [ text content ]\n\nThis works the same on both server and client-side to create basic `<a>` links to pages of your web application.\n\n- `Sitelet.New` creates a Sitelet from a router and handler. Example:\n\n      [<Website>]\n      let Main =\n          Sitelet.New rPages (fun ctx ep ->\n              match ep with\n              | Home -> div [] [ text \"This is the home page\" ]\n              | Contact _ -> client <@ ContactMain() @>\n          )\n\nHere we return a static page for the root, but call into a client-side generated content in the `Contact` pages, which is parsing the URL again to show the contact details from the URL. Sitelets are only a server-side type.\n\n- `Router.Ajax` makes a request from an endpoint value on the client and executes it using `jQuery.ajax`. Returns an `async<string>`, which raises an exception internally if the request fails. Example:\n\n      // [<EndPoint \"/get-data\">] GetData of int\n\n      let GetDataAsyncSafe i =\n          async {\n              try\n                  return! Some (Router.Ajax router (GetData i))\n              with _ ->\n                  None\n          }\n\n---\n\n**Source:** https://developers.websharper.com/docs/v4.x/fs/sitelets"
      }
    ]
  },
  {
    "filename": "websharper_sourceMapping.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/source-mapping",
        "content": "WebSharper Documentation\n\n# Source maps"
      },
      {
        "heading": "Embedding source maps in WebSharper libraries",
        "content": "You can enable including source maps and the required source files in a WebSharper assembly, by adding the\n\n    <WebSharperSourceMap>True</WebSharperSourceMap>\n\nproperty to your project file.\n\nWebSharper itself and all publix is built with source map embedding, so you can debug into WebSharper library code.\n\nSitelets and single-page application projects are supported, offline sitelets (generating static Html+JS output) is currently not."
      },
      {
        "heading": "Outputting source maps for WebSharper web projects",
        "content": "If you have a separate web project hosting your WebSharper application, add the same `WebSharperSourceMap` property to the project file to unpack the source map files."
      },
      {
        "heading": "Usage",
        "content": "### Internet Explorer & Microsoft Edge\n\nYou need to have Internet Explorer 11 on Windows 8.1 Update 1 or newer for source map support. Edge has inherited the debugging tool from IE11, works similarly.\n\nIn the Debugger tab of F12 tools, the last icon in the toolbar says \"Load the sources mapped to this generated file\". Use this to jump between generated and original source code. You can set breakpoints in the original code.\n\n![IE source mapping](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../../images/ExplorerSourceMap.PNG)\n\n### Google Chrome\n\nTo enable source maps, check the \"Enable JavaScript source maps\" setting in Developer Tools Settings (cog icon in F12 panel).\n\nIn the Sources tab of Developer Tools, open a generated `.js` file in the `Scripts/WebSharper` folder to make Chrome load its source mappings. A folder named `Source` will appear with the original `.fs` files used for WebSharper translation. You can use this to set breakpoints in original code.\n\n![Chrome source mapping](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../../images/ChromeSourceMap.PNG)\n\n### Mozilla Firefox\n\nCheck the \"Show Original Sources\" item in the \"Debugger Options\" menu (cog icon in F12 panel)."
      },
      {
        "heading": "You can access the list of original sources, however breakpoints don't work correctly as of version 37.0.1.",
        "content": ""
      }
    ]
  },
  {
    "filename": "websharper_swiper.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/swiper",
        "content": "# Swiper (WebSharper Integration)\n\n[Swiper](http://idangero.us/swiper/) is a JavaScript library to create modern, touch-driven sliders for websites. It works on iOS, Android, and desktop browsers."
      },
      {
        "heading": "Configuring Swiper",
        "content": "Basic HTML layout:\n\n```html\n<div class=\"swiper-container\">\n  <div class=\"swiper-wrapper\">\n    <div class=\"swiper-slide\" data-hash=\"slide1\">Slide 1</div>\n    <div class=\"swiper-slide\" data-hash=\"slide2\">Slide 2</div>\n    ...\n    <div class=\"swiper-slide\" data-hash=\"slide10\">Slide 10</div>\n  </div>\n</div>\n```\n\n### JavaScript Initialization\n\n```javascript\nvar swiper = new Swiper(\".swiper-container\", {\n  direction: \"vertical\",\n  loop: true,\n  onSlideChangeEnd: function (swiper) {\n    console.log(\"Current slide index: \" + swiper.activeIndex);\n  },\n});\n```\n\n### F# Initialization (WebSharper)\n\n```fsharp\nopen WebSharper.Swiper\n\nlet swiper =\n    new Swiper(\n        \".swiper-container\",\n        SwipeParameters(\n            Direction = Direction.Vertical,\n            Loop = true,\n            OnSlideChangeEnd = (fun swiper ->\n                Console.Log(\"Current slide index: \" + (string swiper.ActiveIndex))\n            )\n        )\n    )\n```"
      },
      {
        "heading": "Differences in WebSharper Binding",
        "content": "### Naming\n\n- F# uses PascalCase for methods/properties.\n\n### Working with DOM Elements\n\n- Use `Elt.Dom` for JavaScript interop.\n- Use `Elt.Html` to get the string HTML.\n\n### Using Unions\n\n- `Union<Dom.Element, string>`:\n  - Use `Union1Of2 elt.Dom` for DOM\n  - Use `Union2Of2 \".selector\"` for string\n\n### Example in C#\n\n```csharp\nSwipeParameters swipeParams = new SwipeParameters() {\n    Pagination = \".swiper-pagination\",\n    PaginationClickable = true,\n    NextButton = \".swiper-button-next\",\n    PrevButton = \".swiper-button-prev\",\n    Parallax = true,\n    Speed = 600\n};\n\nSwiper swiper = new Swiper(\".swiper-container\", swipeParams);\nDoc.RunAppendById(\"main\", p());\n```"
      },
      {
        "heading": "Enum Mappings",
        "content": "- **Direction**: `Vertical`, `Horizontal`\n- **ColumnFill**: `Row`, `Column`\n- **TouchEventTargets**: `Container`, `Wrapper`\n- **PaginationType**: `Bullets`, `Fraction`, `Progress`, `Custom`\n- **Auto**: `Auto`\n- **ControlBy**: `Slide`, `Container`\n- **Effect**: `Slide`, `Fade`, `Cube`, `Coverflow`, `Flip`\n\n### Sub-configurations\n\n- **Cube**: `SlideShadows`, `Shadow`, `ShadowOffset`, `ShadowScale`\n- **Fade**: `CrossFade`\n- **Coverflow**: `Rotate`, `Stretch`, `Depth`, `Modifier`, `SlideShadows`\n- **Flip**: `SlideShadows`, `LimitRotation`\n\nUsed inside:\n\n- `SwiperParameters`: Includes all effects and configurations.\n- `Swipe`: `Params`, `Touches`"
      }
    ]
  },
  {
    "filename": "websharper_templates.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/templates",
        "content": "# WebSharper Templates"
      },
      {
        "heading": "Main Application Templates",
        "content": "WebSharper offers three main application types:\n\n1. **Client-Server Application**  \n   A full-stack app using a WebSharper sitelet with dynamic HTML templates. Can run as:\n\n   - **ASP.NET module**\n   - **Self-hosted OWIN executable**\n\n2. **HTML Site**  \n   A multi-page HTML/JS app using sitelets and generating static files for deployment.\n\n3. **Single-Page Application (SPA)**  \n   A one-page HTML/JS app where F# code plugs into a placeholder in the HTML.\n\nHelper project types:\n\n- **Library**: Builds WebSharper libraries.\n- **Extension**: Defines bindings for JS libraries using WIG syntax.\n- **Mobile Application**: SPA ready for Cordova packaging.\n- **OWIN/Suave Site**: Self-hosted Client-Server apps."
      },
      {
        "heading": ".NET Core Support",
        "content": "Templates are available for .NET Core/Standard. See the documentation for installation steps."
      },
      {
        "heading": "MSBuild Project File Configuration",
        "content": "Use the `WebSharperProject` property in `.csproj`/`.fsproj` or `wsconfig.json`. Available project types:\n\n- `Site`: For Client-Server apps. Outputs JS and resources.\n- `Html`: For HTML sites. Generates static HTML + JS.\n- `Bundle`: For SPAs. Bundles JS and CSS.\n- `BundleOnly`: Same as `Bundle`, skips .NET build.\n- `Library`: Builds libraries.\n- `InterfaceGenerator`: For extensions using WIG."
      },
      {
        "heading": "Project Capabilities Summary",
        "content": "| Template Type           | dotnet new ID     | Sitelet | Client | Server | Remote |\n| ----------------------- | ----------------- | ------- | ------ | ------ | ------ |\n| Client-Server (ASP.NET) | `websharper-web`  | âœ…      | âœ…     | âœ…     | âœ…     |\n| Client-Server (OWIN)    | -                 | âœ…      | âœ…     | âœ…     | âœ…     |\n| HTML Site               | `websharper-html` | âœ…      | âœ…     |        |        |\n| SPA (ASP.NET)           | `websharper-spa`  |         | âœ…     |        |        |\n| SPA (Mobile)            | -                 |         | âœ…     |        |        |\n| Library                 | `websharper-lib`  |         |        |        |        |\n\n---\n\nThis version excludes unnecessary crawl metadata, repetitive image links, and reorganizes the data for clarity."
      },
      {
        "heading": "URL: https://developers.websharper.com/docs/v4.x/fs/templates",
        "content": "WebSharper Documentation"
      },
      {
        "heading": "Main Application Templates",
        "content": "The three main WebSharper application types are:\n\n1.  **Client-Server Application** - a full client-server application implemented as a WebSharper [sitelet](Sitelets.md).\n\n    The sitelet uses a dynamic HTML template and placeholders that are instantiated by the sitelet. See the Reactive HTML documentation page for more information on dynamic templating.\n\n    These applications exist in two kinds: a **Client-Server Web Application** runs as an ASP.NET module, while a **Self-Hosted Client-Server Web Application** runs as a self-contained executable using an OWIN self-host container.\n\n2.  **HTML Site** - a multi-page HTML/JavaScript application.\n\n    Like the Client-Server Application, this application also uses [sitelets](Sitelets.md) and dynamic HTML to define web pages. However, it creates a set of static HTML and JavaScript files that can be deployed in any HTML container.\n\n    WebSharper mobile web applications can also be created from this template.\n\n3.  **Single-Page Application** - a single-page HTML/JavaScript application with an HTML page and an F# source file that plugs content into it.\n\n    The easiest way to get started with WebSharper: write a few lines of F#, add a placeholder for it in the HTML, and you are ready to go.\n\n    See the \"Your first app in 2 minutes\" tab for an example.\n\nThe following helper projects are also available:\n\n1.  **Library** - a simple WebSharper library. Annotated code is compiled to JavaScript, and can then be used from any application project.\n2.  **Extension** - defines the interface to an existing JavaScript library using [a convenient declarative F# syntax](wig).\n3.  **Mobile Application** - a single-page application without web hosting and with a readme with instructions about how to wrap the code output in an Apache Cordova application.\n4.  **Owin-hosted Site** - a client-server application with Owin hosting.\n5.  **Suave-hosted Site** - a client-server application with [Suave](https://github.com/SuaveIO/suave) hosting."
      },
      {
        "heading": ".NET Core",
        "content": "Some templates are available for .NET Core/Standard, see [Installing WebSharper Templates for .NET Core/Standard](install#netcore)"
      },
      {
        "heading": "Capabilities",
        "content": "This table summarizes the capabilities of the available application/helper project templates:\n\nTemplate\n\n`dotnet new`\n\nC# available\n\nIs Sitelet?\n\nClient\n\nServer\n\nRemote\n\nApplications\n\nClient-Server App  \nASP.NET / Core\n\n`websharper-web`\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\nClient-Server App  \nHosted via OWIN or Suave\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\nHTML App\n\n`websharper-html`\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\nSingle-Page App  \nASP.NET / Core\n\n`websharper-spa`\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\nSingle-Page App  \nPackaging for mobile\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\nHelpers\n\nLibrary\n\n`websharper-lib`\n\n![X](https://raw.githubusercontent.com/dotnet-websharper/docs/master/v4.x/fsharp/../https://raw.githubusercontent.com/dotnet-websharper/docs/master/images/ok.png)\n\nExtension\n\n- **Client** - Contains code compiled to JavaScript, executing on the client-side.\n- **Server** - Contains code you deploy for your application, executing on your server-side.\n- **Remote** - Contains code you from someone else's server, typically through a web service."
      },
      {
        "heading": "MSBuild Project File Configuration",
        "content": "The WebSharper compiler is included in the NuGet packages `WebSharper.CSharp` and `WebSharper.FSharp`. The type of project is driven by the `Project` value in a `wsconfig.json` file, or the property `WebSharperProject` in the `.csproj`/`.fsproj`. Here are the possible values:\n\n- `Site`: for Client-Server Applications.\n  - Compiles JavaScript-annotated code;\n  - Extracts resources in the folders `Content/WebSharper` and `Scripts/WebSharper`.\n- `Html`: for HTML Applications.\n  - Compiles JavaScript-annotated code;\n  - Generates HTML files in `$(WebSharperHtmlDirectory)` and extracts resources in `$(WebSharperHtmlDirectory)/Content/WebSharper` and `$(WebSharperHtmlDirectory)/Scripts/WebSharper`.\n- `Bundle`: for Single-Page Applications.\n  - Compiles JavaScript-annotated code;\n  - Extracts and concatenates resources (js+css) into the folder `Content`.\n- `BundleOnly`: for Single-Page Applications without .NET compilation.\n  - Same as `Bundle` but skips any other build steps not related to producing the js+css output for quick iterative development.\n- `Library`: for Libraries.\n  - Compiles JavaScript-annotated code.\n- `InterfaceGenerator`: For Extensions.\n  - Compiles the classes defined using WIG into an assembly."
      }
    ]
  },
  {
    "filename": "websharper_testing.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/testing",
        "content": "# WebSharper Documentation: Unit Testing\n\nThe `WebSharper.Testing` library provides a clean F# syntax to write unit tests for libraries, services, and websites. It is a wrapper around `QUnit` and supports synchronous/asynchronous expressions and property testing."
      },
      {
        "heading": "Categories and Tests",
        "content": "### TestCategory\n\nDefines a named category of tests.\n\n```fsharp\nlet MyTests =\n    TestCategory \"MyTests\" {\n        Test \"Equality\" {\n            equal 1 1\n        }\n    }\n```\n\n### Test\n\nDefines a named test. It supports multiple variants including named and async assertions.\n\n```fsharp\nlet EqualityTests() =\n    Test \"Equality\" {\n        equal 1 1\n        notEqual 1 2\n    }\n```\n\n### Runner.RunTests\n\nRuns an array of test categories.\n\n```fsharp\nlet RunAllTests() =\n    Runner.RunTests [| MyTests |]\n```\n\n### Expect\n\nSets the expected number of assertions.\n\n```fsharp\nexpect 2\nequal 1 1\nnotEqual 1 2\n```"
      },
      {
        "heading": "Assertions",
        "content": "### isTrue / isFalse\n\n```fsharp\nisTrue (1 = 1)\nisFalse (1 = 2)\n```"
      },
      {
        "heading": "Equality Checks",
        "content": "### equal / notEqual\n\n```fsharp\nequal (Some 1) (Some 1)\nnotEqual (Some 1) (None)\n```\n\n### jsEqual / notJsEqual\n\nChecks values using JavaScript `==`.\n\n### strictEqual / notStrictEqual\n\nChecks values using JavaScript `===`.\n\n### deepEqual / notDeepEqual\n\nDeep recursive comparison.\n\n### propEqual / notPropEqual\n\nCompares direct properties using `===`.\n\n### approxEqual / notApproxEqual\n\nCompares floats with a tolerance of `< 0.0001`."
      },
      {
        "heading": "Exception Testing",
        "content": "### raises\n\nEnsures an exception is raised.\n\n```fsharp\nraises (failwith \"should fail\")\n```"
      },
      {
        "heading": "Asynchronous Tests",
        "content": "```fsharp\nlet! one = async { return 1 }\nequal one 1\n```"
      },
      {
        "heading": "Property Testing",
        "content": "### property / propertyWith / propertyWithSample\n\n```fsharp\nproperty (fun (x: int) -> Do { equal x x })\npropertyWith RandomValues.Int (fun x -> Do { equal x x })\npropertyWithSample (RandomValues.Sample [|1;2;3|]) (fun x -> Do { equal x x })\n```"
      },
      {
        "heading": "Looping",
        "content": "### forEach\n\n```fsharp\nforEach { 1 .. 3 } (fun x -> Do { equal x x })\n```"
      },
      {
        "heading": "Sample Value Generators",
        "content": "### Generator Record\n\n```fsharp\ntype Generator<'T> = {\n    Base: 'T []\n    Next: unit -> 'T\n}\n```\n\n### Sample\n\n```fsharp\nlet sample = RandomValues.Sample [|1; 2; 3|]\n```\n\n### Generator Constructors\n\n- `RandomValues.Int`, `RandomValues.Float`, `RandomValues.Boolean`, `RandomValues.String`, etc.\n\n### Generator Combinators\n\n- `RandomValues.Map`, `SuchThat`, `ArrayOf`, `Tuple2Of`, `Mix`, `Const`, `OptionOf`, etc."
      }
    ]
  },
  {
    "filename": "websharper_translation.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/translation",
        "content": "# WebSharper Documentation"
      },
      {
        "heading": "Translation and Metaprogramming",
        "content": "WebSharper provides several ways to customize how functions and values are compiled to JavaScript:\n\n- Directly providing JavaScript code\n- Customizing the compiled name of the value\n- Transforming the F# code during compilation (metaprogramming)\n\n### Embedding JavaScript\n\n#### JavaScript Function Body\n\nUse `[<Direct \"...\">]` to provide a JavaScript expression. Parameters can be referenced as `$x`, `$y`, or by index like `$0`, `$1`. In instance methods, `$0` is the `this` reference.\n\n```fsharp\n[<Direct \"$x + $y\">]\nlet add (x: int) (y: int) = X<int>\n```\n\n#### Inlined JavaScript Code\n\nUse `[<Inline \"...\">]` to inline JS code directly at call sites.\n\n```fsharp\n[<Inline \"$x + $y\">]\nlet add (x: int) (y: int) = X<int>\n```\n\n#### Accessing the Global Object\n\nUse `$global` inside inline code to dynamically access `window`:\n\n```fsharp\n[<Inline \"$global.myLibrary.doSomething()\">]\n```\n\n#### Inline Helper\n\n```fsharp\nlet zeroDate = JS.Inline(\"new Date()\")\nlet date = JS.Inline(\"new Date($0)\", 1472226125177L)\n```\n\n#### Constant\n\n```fsharp\n[<Constant 42>]\nlet answer = X<int>\n```\n\n### Naming\n\nUse `[<Name \"name\">]` to control the compiled name.\n\n```fsharp\n[<Name \"add\">]\nlet OriginalNameForAdd (x: int) (y: int) = x + y\n```\n\nFor abstract/interface members, conflicts in overridden names raise compile errors.\n\n### Metaprogramming\n\nTwo mechanisms exist:\n\n- `[<Generated>]` - define the body at compile time.\n- `[<Macro>]` - control how a function is compiled across call sites.\n\nDocumentation for macro/generator APIs is in progress."
      }
    ]
  },
  {
    "filename": "websharper_ui.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/ui",
        "content": "# Functional Reactive Programming and HTML\n\nWebSharper.UI is a library providing a novel, pragmatic and convenient approach to UI reactivity. It includes:\n\n- An [HTML library](#html) usable both from the server side and from the client side, which you can use to build HTML pages either by calling F# functions to create elements, or by instantiating template HTML files.\n- A [reactive layer](#reactive) for expressing user inputs and values computed from them as time-varying values. This approach is related to Functional Reactive Programming (FRP). This reactive system integrates with the HTML library to create reactive documents. If you are familiar with Facebook React, then you will find some similarities with this approach: instead of explicitly inserting, modifying and removing DOM nodes, you return a value that represents a DOM tree based on inputs. The main difference is that these inputs are nodes of the reactive system, rather than a single state value associated with the component.\n- Client-side [routing](#routing) using the same endpoint type declaration as [WebSharper server-side routing](sitelets).\n\nThis page is an overview of the capabilities of WebSharper.UI. You can also check [the full reference of all the API types and modules](https://developers.websharper.com/api/WebSharper.UI).\n\nGet the package from NuGet: [WebSharper.UI](https://www.nuget.org/packages/websharper.ui)."
      },
      {
        "heading": "Using HTML",
        "content": "WebSharper.UI's core type for HTML construction is [`Doc`](/api/v4.1/WebSharper.UI.Doc). A Doc can represent a single DOM node (element, text), but it can also be a sequence of zero or more nodes. This allows you to treat equally any HTML snippet that you want to insert into a document, whether it consists of a single element or not.\n\nAdditionally, client-side Docs can be reactive. A same Doc can consist of different elements at different moments in time, depending on user input or other variables. See [the reactive section](#reactive) to learn more about this.\n\n### Constructing HTML\n\n#### Docs\n\nThe main means of creating Docs is by using the functions in the [`WebSharper.UI.Html`](/api/v4.1/WebSharper.UI.Html) module. Every HTML element has a dedicated function, such as [`div`](/api/v4.1/WebSharper.UI.Html#div) or [`p`](/api/v4.1/WebSharper.UI.Html#p), which takes a sequence of [attributes](#attr) (of type [`Attr`](/api/v4.1/WebSharper.UI.Attr)) and a sequence of child nodes (of type `Doc`). Additionally, the [`text`](/api/v4.1/WebSharper.UI.Html#text) function creates a text node.\n\n    open WebSharper.UI.Html\n\n    let myDoc =\n        div [] [\n            h1 [] [ text \"Functional Reactive Programming and HTML\" ]\n            p [] [ text \"WebSharper.UI is a library providing a novel, pragmatic and convenient approach to UI reactivity. It includes:\" ]\n            ul [] [\n                li [] [ text \"...\" ]\n            ]\n        ]\n\nResult:\n\n    <div>\n      <h1>Functional Reactive Programming and HTML</h1>\n      <p>WebSharper.UI is a library providing a novel, pragmatic and convenient\n         approach to UI reactivity. It includes:</p>\n      <ul>\n        <li>...</li>\n      </ul>\n    </div>\n\nSome HTML tags, such as `option`, collide with standard library names and are therefore only located in the [`Tags`](/api/v4.1/WebSharper.UI.Html.Tags) submodule.\n\n    let myDropdown =\n        select [] [\n            Tags.option [] [ text \"First choice\" ]\n            Tags.option [] [ text \"Second choice\" ]\n            Tags.option [] [ text \"Third choice\" ]\n        ]\n\nResult:\n\n    <select>\n      <option>First choice</option>\n      <option>Second choice</option>\n      <option>Third choice</option>\n    </select>\n\nOne thing to note is that the tag functions described above actually return a value of type [`Elt`](/api/v4.1/WebSharper.UI.Elt), which is a subtype of `Doc` that is guaranteed to always consist of exactly one element and provides additional APIs such as [`Dom`](/api/v4.1/WebSharper.UI.Elt#Dom) to get the underlying `Dom.Element`. This subtyping means that you will sometimes need to upcast the result of such a function with `:> Doc` to appease the compiler; you can see an example of this below in the example for `Doc.Empty`.\n\nAdditional functions in the [`Doc`](/api/v4.1/WebSharper.UI.Doc) can create or combine Docs:\n\n- [`Doc.Empty`](/api/v4.1/WebSharper.UI.Doc#Empty) creates a Doc consisting of zero nodes. This can be useful for example when you may not need to insert an element depending on a condition.\n\n      let myForm (withDropdown: bool) =\n          form [] [\n              input [ attr.name \"name\" ] []\n              (if withDropdown then myDropdown :> Doc else Doc.Empty)\n          ]\n\n  Result:\n\n      <form>\n        <input name=\"name\" />\n      </form>\n\n      or:\n\n      <form>\n        <input name=\"name\" />\n        <!-- ... contents of myDropdown here ... -->\n      </form>\n\n- [`Doc.Append`](/api/v4.1/WebSharper.UI.Doc#Append) creates a Doc consisting of the concatenation of two Docs.\n\n      let titleAndBody =\n          Doc.Append\n              (h1 [] [ text \"Functional Reactive Programming and HTML\" ])\n              (p [] [ text \"WebSharper.UI is a library providing ...\" ])\n\n  Result:\n\n      <h1>Functional Reactive Programming and HTML</h1>\n      <p>WebSharper.UI is a library providing ...</p>\n\nFor the mathematically enclined, the functions `Doc.Empty` and `Doc.Append` make Docs a monoid.\n\n- [`Doc.Concat`](/api/v4.1/WebSharper.UI.Doc#Concat) generalizes `Append` by concatenating a sequence of Docs.\n\n      let thisPage =\n          Doc.Concat [\n              h1 [] [ text \"Functional Reactive Programming and HTML\" ]\n              p [] [ text \"WebSharper.UI is a library providing ...\" ]\n              ul [] [\n                  li [] [ text \"...\" ]\n              ]\n          ]\n\n  Result:\n\n      <h1>Functional Reactive Programming and HTML</h1>\n      <p>WebSharper.UI is a library providing ...</p>\n      <ul>\n        <li>...</li>\n      </ul>\n\n- [`Doc.Element`](/api/v4.1/WebSharper.UI.Doc#Element) creates an element with the given name, attributes and children. It is equivalent to the function with the same name from the `Html` module. This function is useful if the tag name is only known at runtime, or if you want to create a non-standard element that isn't available in `Html`. The following example creates a header tag of a given level (`h1`, `h2`, etc).\n\n      let makeHeader (level: int) (content: string) =\n          Doc.Element (\"h\" + string level) [] [ text content ]\n\n  Result:\n\n      <h1>content...</h1>\n      or\n      <h2>content...</h2>\n      or etc.\n\n- [`Doc.Verbatim`](/api/v4.1/WebSharper.UI.Doc#Verbatim) creates a Doc from plain HTML text.  \n  **Security warning:** this function does not perform any checks on the contents, and can be a code injection vulnerability if used improperly. We recommend avoiding it unless absolutely necessary, and properly sanitizing user inputs if you do use it. If you simply want to use HTML syntax instead of F# functions, take a look at [templating](#templating).\n\n      let plainDoc =\n          Doc.Verbatim \"\n              <h1 onclick=\\\"alert('And it is unsafe!')\\\">\n                  This is plain HTML!\n              </h1>\"\n\n  Result:\n\n      <h1 onclick=\"alert('And it is unsafe!')\">\n          This is plain HTML!\n      </h1>\n\n#### Attrs\n\nTo create attributes, use corresponding functions from the [`attr`](/api/v4.1/WebSharper.UI.Html.attr) submodule.\n\n    let myFormControl =\n        select [ attr.name \"mySelect\" ] [\n            Tags.option [ attr.value \"first\" ] [ text \"First choice\" ]\n            Tags.option [ attr.value \"second\" ] [ text \"Second choice\" ]\n            Tags.option [\n                attr.value \"third\"\n                attr.selected \"selected\"\n            ] [ text \"Third choice\" ]\n        ]\n\nResult:\n\n    <select name=\"mySelect\">\n      <option value=\"first\">First choice</option>\n      <option value=\"second\">Second choice</option>\n      <option value=\"third\" selected=\"selected\">Third choice</option>\n    </select>\n\nSome attributes, notably `class` and `type`, are also F# keywords, so they need to be wrapped in double backquotes.\n\n    let myMain =\n        div [ attr.``class`` \"main\" ] [ text \"...\" ]\n\nResult:\n\n    <div class=\"main\">...</div>\n\nHTML5 also defines any attribute whose names starts with `data-` as a valid custom attribute. You can create such an attribute using the function `data-` from module `attr` (backquoted since it contains a non-standard character).\n\n    let myEltWithData =\n        div [ attr.``data-`` \"uid\" \"myDiv\" ] [ text \"...\" ]\n\nResult:\n\n    <div data-uid=\"myDiv\">...</div>\n\nLike `Doc`, a value of type `Attr` can represent zero, one or more attributes. The functions in the [`Attr`](/api/v4.1/WebSharper.UI.Attr) module can create such non-singleton attributes.\n\n- [`Attr.Empty`](/api/v4.1/WebSharper.UI.Attr#Empty) creates an empty attribute. This can be useful for example when you may not need to insert an attribute depending on a condition.\n\n      let makeInput (initialValue: option<string>) =\n          let valueAttr =\n              match initialValue with\n              | Some v -> attr.value v\n              | None -> Attr.Empty\n          input [ valueAttr ] []\n\n  Result:\n\n      <input value=\"initialValue...\" />\n      or\n      <input />\n\n- [`Attr.Append`](/api/v4.1/WebSharper.UI.Attr#Append) combines two attributes.\n\n      let passwordAttr =\n          Attr.Append (attr.``type`` \"password\") (attr.placeholder \"Password\")\n\n  Result:\n\n      type=\"password\" placeholder=\"Password\"\n\n- [`Attr.Concat`](/api/v4.1/WebSharper.UI.Attr#Concat) combines a sequence of attributes.\n\n      let passwordAttr =\n          Attr.Concat [\n              attr.``type`` \"password\"\n              attr.placeholder \"Password\"\n              attr.``class`` \"pw-input\"\n          ]\n\n  Result:\n\n      type=\"password\" placeholder=\"Password\" class=\"pw-input\"\n\n- [`Attr.Create`](/api/v4.1/WebSharper.UI.Attr#Create) creates a single attribute. It is equivalent to the function with the same name from the `attr` module. This function is useful if the attribute name is only known at runtime, or if you want to create a non-standard attribute that isn't available in `attr`.\n\n      let eltWithNonStandardAttr =\n          div [ Attr.Create \"my-attr\" \"my-value\" ] [ text \"...\" ]\n\n  Result:\n\n      <div my-attr=\"my-value\">...</div>\n\n#### Event handlers\n\nA special kind of attribute is event handlers. They can be created using functions from the [`on`](/api/v4.1/WebSharper.UI.Html#on) submodule.\n\n    let myButton =\n        button [ on.click (fun el ev -> JS.Alert \"Hi!\") ] [ text \"Click me!\" ]\n\nThe handler function takes two arguments:\n\n- The element itself, as a native `Dom.Element`;\n- The triggered event, as a native `Dom.Event`.\n\n  let myButton =\n  button [\n  attr.id \"my-button\"\n  on.click (fun el ev ->\n  JS.Alert (sprintf \"You clicked %s at x = %i, y = %i.\"\n  el.Id ev.ClientX ev.ClientY)\n  )\n  ] [ text \"Click me!\" ]\n\nIn addition to the standard HTML events, `on.afterRender` is a special handler that is called by WebSharper after inserting the element into the DOM.\n\n### HTML on the client\n\nTo insert a Doc into the document on the client side, use the `Doc.Run*` family of functions from the module [`WebSharper.UI.Client`](/api/v4.1/WebSharper.UI.Client). Each of these functions has two variants: one directly taking a DOM [`Element`](/api/v4.1/WebSharper.JavaScript.Dom.Element) or [`Node`](/api/v4.1/WebSharper.JavaScript.Dom.Node), and the other suffixed with `ById` taking the id of an element as a string.\n\n- [`Doc.Run`](/api/v4.1/WebSharper.UI.Doc#Run) and [`Doc.RunById`](/api/v4.1/WebSharper.UI.Doc#RunById) insert a given Doc as the child(ren) of a given DOM element. Note that it replaces the existing children, if any.\n\n      open WebSharper.JavaScript\n      open WebSharper.UI\n      open WebSharper.UI.Client\n      open WebSharper.UI.Html\n\n      let Main () =\n          div [] [ text \"This goes into #main.\" ]\n          |> Doc.RunById \"main\"\n\n          p [] [ text \"This goes into the first paragraph with class my-content.\" ]\n          |> Doc.Run (JS.Document.QuerySelector \"p.my-content\")\n\n- [`Doc.RunAppend`](/api/v4.1/WebSharper.UI.Doc#RunAppend) and [`Doc.RunAppendById`](/api/v4.1/WebSharper.UI.Doc#RunAppendById) insert a given Doc as the last child(ren) of a given DOM element.\n- [`Doc.RunPrepend`](/api/v4.1/WebSharper.UI.Doc#RunPrepend) and [`Doc.RunPrependById`](/api/v4.1/WebSharper.UI.Doc#RunPrependById) insert a given Doc as the first child(ren) of a given DOM element.\n- [`Doc.RunAfter`](/api/v4.1/WebSharper.UI.Doc#RunAfter) and [`Doc.RunAfterById`](/api/v4.1/WebSharper.UI.Doc#RunAfterById) insert a given Doc as the next sibling(s) of a given DOM node.\n- [`Doc.RunBefore`](/api/v4.1/WebSharper.UI.Doc#RunBefore) and [`Doc.RunBeforeById`](/api/v4.1/WebSharper.UI.Doc#RunBeforeById) insert a given Doc as the previous sibling(s) of a given DOM node.\n- [`Doc.RunReplace`](/api/v4.1/WebSharper.UI.Doc#RunReplace) and [`Doc.RunReplaceById`](/api/v4.1/WebSharper.UI.Doc#RunReplaceById) insert a given Doc replacing a given DOM node.\n\n### HTML on the server\n\nOn the server side, using [sitelets](sitelets), you can create HTML pages from Docs by passing them to the `Body` or `Head` arguments of `Content.Page`.\n\n    open WebSharper.Sitelets\n    open WebSharper.UI\n    open WebSharper.UI.Html\n\n    let MyPage (ctx: Context<EndPoint>) =\n        Content.Page(\n            Title = \"Welcome!\",\n            Body = [\n                h1 [] [ text \"Welcome!\" ]\n                p [] [ text \"This is my home page.\" ]\n            ]\n        )\n\nBy opening `WebSharper.UI.Server`, you can also just pass a full page to `Content.Page`. This is particularly useful together with [templates](#templating).\n\n    let MyPage (ctx: Context<EndPoint>) =\n        Content.Page(\n            html [] [\n                head [] [ title [] [ text \"Welcome!\" ] ]\n                body [] [\n                    h1 [] [ text \"Welcome!\" ]\n                    p [] [ text \"This is my home page.\" ]\n                ]\n            ]\n        )\n\nTo include client-side elements inside a page, use the `client` method, from inside `WebSharper.UI.Html`.\n\n    [<JavaScript>]\n    module Client =\n\n        let MyControl() =\n            button [ on.click (fun el ev -> JS.Alert \"Hi!\") ] [ text \"Click me!\" ]\n\n    module Server =\n\n        let MyPage (ctx: Context<EndPoint>) =\n            Content.Page(\n                Title = \"Welcome!\",\n                Body = [\n                    h1 [] [ text \"Welcome!\" ]\n                    p [] [ client <@ Client.MyControl() @> ]\n                ]\n            )"
      },
      {
        "heading": "HTML Templates",
        "content": "WebSharper.UI's syntax for creating HTML is compact and convenient, but sometimes you do need to include a plain HTML file in a project. It is much more convenient for designing to have a .html file that you can touch up and reload your application without having to recompile it. This is what Templates provide. Templates are HTML files that can be loaded by WebSharper.UI, and augmented with special elements and attributes that provide additional functionality:\n\n- Declaring Holes for nodes, attributes and event handlers that can be filled at runtime by F# code;\n- Declaring two-way binding between F# Vars and HTML input elements (see [reactive](#reactive));\n- Declaring inner Templates, smaller HTML widgets within the page, that can be instantiated dynamically.\n\nAll of these are parsed from HTML at compile time and provided as F# types and methods, ensuring that your templates are correct.\n\n### Basics\n\nTo declare a template, use the `Template` type provider from the namespace `WebSharper.UI.Templating`.\n\n    open WebSharper.UI.Templating\n\n    type MyTemplate = Template<\"my-template.html\">\n\nTo instantiate it, call your type's constructor and then its `.Doc()` method.\n\nmy-template.html:\n\n    <div>\n      <h1>Welcome!</h1>\n      <p>Welcome to my site.</p>\n    </div>\n\n\n    open WebSharper.UI.Templating\n\n    type MyTemplate = Template<\"my-template.html\">\n\n    let myPage = MyTemplate().Doc()\n\nequivalent to:\n\n    let myPage =\n        div [] [\n            h1 [] [ text \"Welcome!\" ]\n            p [] [ text \"Welcome to my site.\" ]\n        ]\n\nNote that the template doesn't have to be a full HTML document, but can simply be a snippet or sequence of snippets. This is particularly useful to build a library of widgets using [inner templates](#inner-templates).\n\nIf the template comprises a single HTML element, then an additional method `.Elt()` is available. It is identical to `.Doc()`, except its return value has type `Elt` instead of `Doc`.\n\nYou can also declare a template from multiple files at once using a comma-separated list of file names. In this case, the template for each file is a nested class named after the file, truncated of its file extension.\n\nmy-template.html:\n\n    <div>\n      <h1>Welcome!</h1>\n      <p>Welcome to my site.</p>\n    </div>\n\nsecond-template.html:\n\n    <div>\n      <h2>This is a section.</h2>\n      <p>And this is its content.</p>\n    </div>\n\n\n    open WebSharper.UI.Templating\n\n    type MyTemplate = Template<\"my-template.html, second-template.html\">\n\n    let myPage =\n        Doc.Concat [\n            MyTemplate.``my-template``().Doc()\n            MyTemplate.``second-template``().Doc()\n        ]\n\nequivalent to:\n\n    let myPage =\n        Doc.Concat [\n            div [] [\n                h1 [] [ text \"Welcome!\" ]\n                p [] [ text \"Welcome to my site.\" ]\n            ]\n            div [] [\n                h2 [] [ text \"This is a section.\" ]\n                p [] [ text \"And this is its content.\" ]\n            ]\n       ]\n\n### Holes\n\nYou can add holes to your template that will be filled by F# code. Each hole has a name. To fill a hole in F#, call the method with this name on the template instance before finishing with `.Doc()`.\n\n- `${HoleName}` creates a `string` hole. You can use it in text or in the value of an attribute.\n\n  my-template.html:\n\n      <div style=\"background-color: ${Color}\">\n        <h1>Welcome, ${Name}!</h1>\n        <!-- You can use the same hole name multiple times,\n             and they will all be filled with the same F# value. -->\n        <p>This div's color is ${Color}.</p>\n      </div>\n\n\n      let myPage =\n          MyTemplate()\n              .Color(\"red\")\n              .Name(\"my friend\")\n              .Doc()\n\n  Result:\n\n      <div style=\"background-color: red\">\n        <h1>Welcome, my friend!</h1>\n        <!-- You can use the same hole name multiple times,\n             and they will all be filled with the same F# value. -->\n        <p>This div's color is red.</p>\n      </div>\n\n  On the client side, this hole can also be filled with a `View<string>` (see [reactive](#reactive)) to include dynamically updated text content.\n\n- The attribute `ws-replace` creates a `Doc` or `seq<Doc>` hole. The element on which this attribute is set will be replaced with the provided Doc(s). The name of the hole is the value of the `ws-replace` attribute.\n\n  my-template.html:\n\n      <div>\n        <h1>Welcome!</h1>\n        <div ws-replace=\"Content\"></div>\n      </div>\n\n\n      let myPage =\n          MyTemplate()\n              .Content(p [] [ text \"Welcome to my site.\" ])\n              .Doc()\n\n  Result:\n\n      <div>\n        <h1>Welcome!</h1>\n        <p>Welcome to my site.</p>\n      </div>\n\n- The attribute `ws-hole` creates a `Doc` or `seq<Doc>` hole. The element on which this attribute is set will have its _contents_ replaced with the provided Doc(s). The name of the hole is the value of the `ws-hole` attribute.\n\n  my-template.html:\n\n      <div>\n        <h1>Welcome!</h1>\n        <div ws-hole=\"Content\"></div>\n      </div>\n\n\n      let myPage =\n          MyTemplate()\n              .Content(p [] [ text \"Welcome to my site.\" ])\n              .Doc()\n\n  Result:\n\n      <div>\n        <h1>Welcome!</h1>\n        <div>\n            <p>Welcome to my site.</p>\n        </div>\n      </div>\n\n- The attribute `ws-attr` creates an `Attr` or `seq<Attr>` hole. The name of the hole is the value of the `ws-attr` attribute.\n\n  my-template.html:\n\n      <div ws-attr=\"MainDivAttr\">\n        <h1>Welcome!</h1>\n        <p>Welcome to my site.</p>\n      </div>\n\n\n      let myPage =\n          MyTemplate()\n              .MainDivAttr(attr.``class`` \"main\")\n              .Doc()\n\n  Result:\n\n      <div class=\"main\">\n        <h1>Welcome!</h1>\n        <p>Welcome to my site.</p>\n      </div>\n\n- The attribute `ws-var` creates a `Var` hole (see [reactive](#reactive)) that is bound to the element. It can be used on the following elements:\n\n  - `<input>`, `<textarea>`, `<select>`, for which it creates a `Var<string>` hole.\n  - `<input type=\"number\">`, for which it creates a hole that can be one of the following types: `Var<int>`, `Var<float>`, `Var<CheckedInput<int>>`, `Var<CheckedInput<float>>`.\n  - `<input type=\"checkbox\">`, for which it creates a `Var<bool>` hole.\n\n  The name of the hole is the value of the `ws-var` attribute. Text `${Hole}`s with the same name can be used, and they will dynamically match the value of the Var.\n\n  my-template.html:\n\n      <div>\n        <input ws-var=\"Name\" />\n        <div>Hi, ${Name}!</div>\n      </div>\n\n\n      let myPage =\n          let varName = Var.Create \"\"\n          MyTemplate()\n              .Name(varName)\n              .Doc()\n\n  Result:\n\n      <div class=\"main\">\n        <input />\n        <div>Hi, [value of above input]!</div>\n      </div>\n\n  If you don't fill the hole (ie you don't call `.Name(varName)` above), the `Var` will be implicitly created, so `${Name}` will still be dynamically updated from the user's input.\n\n- The attribute `ws-onclick` (or any other event name instead of `click`) creates an event handler hole of type `TemplateEvent -> unit`. The argument of type `TemplateEvent` has the following fields:\n\n  - `Target: Dom.Element` is the element itself.\n  - `Event: Dom.Event` is the event triggered.\n  - `Vars` has a field for each of the `Var`s associated to `ws-var`s in the template.\n\n  my-template.html:\n\n      <div>\n        <input ws-var=\"Name\" />\n        <button ws-onclick=\"Click\">Ok</button>\n      </div>\n\n\n      let myPage =\n          MyTemplate()\n              .Click(fun t -> JS.Alert(\"Hi, \" + t.Vars.Name.Value))\n              .Doc()\n\n### Filling holes\n\nThere are two ways to fill the content for a given hole.\n\n- The recommended way is by using the method with the hole's name on the template instance, as used in the examples above.\n\n      let myPage =\n          MyTemplate()\n              .Color(\"red\")\n              .Name(\"my friend\")\n              .Doc()\n\n- If you need to decide which hole to fill at runtime, you can use the method `.With(holeName, content)`. It will throw a runtime error if the content's type doesn't match the hole's type.\n\n      let myPage =\n          MyTemplate()\n              .With(\"Color\", \"red\")\n              .With(\"Name\", \"my friend\")\n              .Doc()\n\n- You can of course mix and match both styles.\n\n      let myPage =\n          MyTemplate()\n              .Color(\"red\")\n              .With(\"Name\", \"my friend\")\n              .Doc()\n\n### Inner templates\n\nTo create a template for a widget (as opposed to a full page), you can put it in its own dedicated template file, but another option is to make it an inner template. An inner template is a smaller template declared inside a template file using the following syntax:\n\n- The `ws-template` attribute declares that its element is a template whose name is the value of this attribute.\n- The `ws-children-template` attribute declares that the children of its element is a template whose name is the value of this attribute.\n\nInner templates are available in F# as a nested class under the main provided type.\n\nmy-template.html:\n\n    <div ws-attr=\"MainAttr\">\n      <div ws-replace=\"InputFields\"></div>\n      <div ws-template=\"Field\" class=\"field-wrapper\">\n        <label for=\"${Id}\">${Which} Name: </label>\n        <input ws-var=\"Var\" placeholder=\"${Which} Name\" name=\"${Id}\" />\n      </div>\n    </div>\n\n\n    type MyTemplate = Template<\"my-template.html\">\n\n    let inputField (id: string) (which: string) (var: Var<string>) =\n        MyTemplate.Field()\n            .Id(id)\n            .Which(which)\n            .Var(var)\n            .Doc()\n\n    let myForm =\n        let firstName = Var.Create \"\"\n        let lastName = Var.Create \"\"\n        MyTemplate()\n            .MainAttr(attr.``class`` \"my-form\")\n            .InputFields(\n                [\n                    inputField \"first\" \"First\" firstName\n                    inputField \"last\" \"Last\" lastName\n                ]\n            )\n            .Doc()\n\nResult:\n\n    <div class=\"my-form\">\n      <div class=\"field-wrapper\">\n        <label for=\"first\">First Name: </label>\n        <input placeholder=\"First Name\" name=\"first\" />\n      </div>\n      <div class=\"field-wrapper\">\n        <label for=\"last\">Last Name: </label>\n        <input placeholder=\"Last Name\" name=\"last\" />\n      </div>\n    </div>\n\n### Instantiating templates in HTML\n\nYou can also instantiate a template within another template, entirely in HTML, without the need for F# to glue them together.\n\nA node named `<ws-TemplateName>` instantiates the inner template `TemplateName` from the same file. A node named `<ws-fileName.TemplateName>` instantiates the inner template `TemplateName` from the file `fileName`. The file name is the same as the generated class name, so with file extension excluded.\n\nChild elements of the `<ws-*>` fill holes. These elements are named after the hole they fill.\n\n- `${Text}` holes are filled with the text content of the element.\n- `ws-hole` and `ws-replace` holes are filled with the HTML content of the element.\n- `ws-attr` holes are filled with the attributes of the element.\n- Other types of holes cannot be directly filled like this.\n\nAdditionally, attributes on the `<ws-*>` element itself define hole mappings. That is to say, `<ws-MyTpl Inner=\"Outer\">` fills the hole named `Inner` of the template `MyTpl` with the value of the hole `Outer` of the containing template. As a shorthand, `<ws-MyTpl Attr>` is equivalent to `<ws-MyTpl Attr=\"Attr\">`.\n\nAny holes that are neither mapped by an attribute nor filled by a child element are left empty.\n\nThe following example is equivalent to the example from [Inner Templates](#inner-templates):\n\nmy-template.html:\n\n    <div ws-attr=\"MainAttr\">\n      <!-- Instantiate the template for input fields. -->\n      <!-- Creates the holes FirstVar and SecondVar for the main template. -->\n      <!-- Fills the holes Id, Which and Var of Field in both instantiations. -->\n      <ws-Field Var=\"FirstVar\">\n        <Id>first</Id>\n        <Which>First</Which>\n      </ws-field>\n      <ws-Field Var=\"SecondVar\">\n        <Id>last</Id>\n        <Which>Last</Which>\n      </ws-field>\n    </div>\n    <!-- Declare the template for input fields -->\n    <div ws-template=\"Field\" class=\"field-wrapper\">\n      <label for=\"${Id}\">${Which} Name: </label>\n      <input ws-var=\"Var\" placeholder=\"${Which} Name\" name=\"${Id}\" />\n    </div>\n\n\n    type MyTemplate = Template<\"my-template.html\">\n\n    let myForm =\n        let firstName = Var.Create \"\"\n        let lastName = Var.Create \"\"\n        MyTemplate()\n            .FirstVar(firstName)\n            .SecondVar(lastName)\n            .Doc()\n\n### Controlling the loading of templates\n\nThe type provider can be parameterized to control how its contents are loaded both on the server and the client. For example:\n\n    type MyTemplate =\n        Template<\"my-template.html\",\n            clientLoad = ClientLoad.Inline,\n            serverLoad = ServerLoad.WhenChanged>\n\nThe possible values for `clientLoad` are:\n\n- `ClientLoad.Inline` (default): The template is included in the compiled JavaScript code, and any change to `my-template.html` requires a recompilation to be reflected in the application.\n- `ClientLoad.FromDocument`: The template is loaded from the DOM. This means that `my-template.html` _must_ be the document in which the code is run: either directly served as a Single-Page Application, or passed to `Content.Page` in a Client-Server Application.\n\n  In this mode, it doesn't make sense for client-side code to instantiate the full template, since you are already inside the document. But the following are possible:\n\n  - [Instantiating inner templates.](#inner-templates)\n  - [Binding directly to the DOM.](#binding-dom)\n\nThe possible values for `serverLoad` are:\n\n- `ServerLoad.WhenChanged` (default): The runtime sets up a file watcher on the template file, and reloads it whenever it is edited.\n- `ServerLoad.Once`: The template file is loaded on first use and never reloaded.\n- `ServerLoad.PerRequest`: The template file is reloaded every time it is needed. We recommend against this option for performance reasons.\n\n### Binding directly to the DOM\n\nWhen using a template from the client side that is declared with `clientLoad = ClientLoad.FromDocument`, you can directly bind content, Vars, etc. to the DOM. Instead of calling `.Doc()` to create a Doc, use `.Bind()`, which returns `unit`, to just apply the template to the current document.\n\nindex.html:\n\n    <html>\n      <head>\n        <title>Welcome!</title>\n      </head>\n      <body>\n        <h1>Welcome!</h1>\n        <div ws-replace=\"Paragraph\"></div>\n        <button ws-onclick=\"ClickMe\">${ClickText}</button>\n      </body>\n    </html>\n\n\n    type Index = Template<\"index.html\", ClientLoad.FromDocument>\n\n    Index()\n        .Paragraph(p [] [text \"Welcome to my site.\"])\n        .ClickMe(fun _ -> JS.Alert \"Clicked!\")\n        .ClickText(\"Click me!\")\n        .Bind()\n\nResult:\n\n    <html>\n      <head>\n        <title>Welcome!</title>\n      </head>\n      <body>\n        <h1>Welcome!</h1>\n        <p>Welcome to my site.</p>\n        <button>Click me!</button>\n      </body>\n    </html>\n\nNote that for `Bind()` to work correctly, the holes need to be present in the document itself. This is not a problem if your project is an SPA. But you can also serve the page from a Sitelet, using the same template on the server side. You can fill some holes on the server side and leave some to be filled by the client side. However, by default, the server-side engine removes unfilled holes from the served document. This is correct behavior in most cases, but here, the client does need the unfilled hole markers like `ws-replace` or `${...}` to be present. So this behavior can be overridden by the optional boolean argument `keepUnfilled` of the `.Doc()` and `.Elt()` methods.\n\nindex.html:\n\n    <html>\n      <head>\n        <title>Welcome!</title>\n      </head>\n      <body>\n        <h1>Welcome!</h1>\n        <div ws-replace=\"Paragraph\"></div>\n        <button ws-onclick=\"ClickMe\">${ClickText}</button>\n      </body>\n    </html>\n\n\n    type Index = Template<\"index.html\", ClientLoad.FromDocument>\n\n    [<JavaScript>]\n    module Client =\n\n        let Startup() =\n            Index()\n                .ClickMe(fun _ -> JS.Alert \"Clicked!\")\n                .ClickText(\"Click me!\")\n                .Bind()\n\n    module Server =\n        open WebSharper.UI.Server\n\n        let MyPage() =\n            Content.Page(\n                Index()\n                    .Paragraph(p [] [text \"Welcome to my site.\"])\n                    .Elt(keepUnfilled = true)\n                    .OnAfterRender(fun _ -> Client.Startup())\n            )\n\nServed page:\n\n    <html>\n      <head>\n        <title>Welcome!</title>\n      </head>\n      <body>\n        <h1>Welcome!</h1>\n        <p>Welcome to my site.</p>\n        <button ws-onclick=\"ClickMe\">${ClickText}</button>\n      </body>\n    </html>\n\nResult after Client.Startup() has run:\n\n    <html>\n      <head>\n        <title>Welcome!</title>\n      </head>\n      <body>\n        <h1>Welcome!</h1>\n        <p>Welcome to my site.</p>\n        <button>Click me!</button>\n      </body>\n    </html>\n\n### Accessing the template's model\n\nTemplates allow you to access their \"model\", ie the set of all the reactive `Var`s that are bound to it, whether passed explicitly or automatically created for its `ws-var`s. It is accessible in two ways:\n\n- In event handlers, it is available as the `Vars` property of the handler argument.\n- From outside the template: instead of finishing the instanciation of a template with `.Doc()`, you can call `.Create()`. This will return a `TemplateInstance` with two properties: `Doc`, which returns the template itself, and `Vars`, which contains the Vars. This method is only available when instantiating the template from the client side.\n\n  my-template.html:\n\n      <div>\n        <input ws-var=\"Name\" />\n        <div>Hi, ${Name}!</div>\n      </div>\n\n\n      let myInstance = MyTemplate().Create()\n      myInstance.Vars.Name <- \"John Doe\"\n      let myDoc = myInstance.Doc\n\n  Result:\n\n      <div>\n        <input value=\"John Doe\" />\n        <div>Hi, John Doe!</div>\n      </div>\n\n### Mixing client code in server-side templates\n\nIt is possible to include some client-side functionality when creating a template on the server side.\n\n- If you use `ws-var=\"VarName\"`, the corresponding Var will be created on the client on page startup. However, passing a Var using `.VarName(myVar)` is not possible, since it would be a server-side Var.\n- Event handlers (such as `ws-onclick=\"EventName\"`) work fully if you pass an anonymous function: `.EventName(fun e -> ...)`. The body of this function will be compiled to JavaScript. You can also pass a top-level function, in this case it must be declared with `[<JavaScript>]`.\n\n  This also includes `ws-onafterrender`, which causes the given function to be called on page startup.\n\n### Special holes in server-side templates\n\nIn a server-side template, you must specify the location of where WebSharper can include its generated content. Three special placeholders are provided to include client-side content in the page:\n\n- `scripts` is replaced with the JavaScript files required by the client-side code included in the page (including WebSharper-generated `.js` files). Usage: `<script ws-replace=\"scripts\"></script>`\n- `styles` is replaced with the CSS files required by the client-side code included in the page. Usage: `<link ws-replace=\"styles\" />`\n- `meta` is replaced with a `<meta>` tag that contains initialization data for client-side controls. Usage: `<meta ws-replace=\"meta\" />`\n\nThe `scripts` hole is necessary for correct working of the served page if it contains any client-side WebSharper functionality. The other two are optional: if neither `styles` nor `meta` is provided explicilty, then they are included automatically above the content for `scripts`.\n\n### Dynamic templates\n\nIt is also possible to create a template without the compile-time safety of the type provider. This is done using the type `DynamicTemplate`.\n\nThis type can be used similarly to `Template<...>`, with the following limitations:\n\n- It is server-side only.\n- Its constructor must receive the HTML source as a string.\n- Holes can only be filled with `.With(holeName, content)`.\n- The final instantiation must be done with `.Doc()`.\n\n  let myPage =\n  DynamicTemplate(\"\"\"<div style=\"background-color: ${Color}\">Welcome, ${Name}!</div>\"\"\")\n  .With(\"Color\", \"red\")\n  .With(\"Name\", \"my friend\")\n  .Doc()"
      },
      {
        "heading": "Reactive layer",
        "content": "WebSharper.UI's reactive layer helps represent user inputs and other time-varying values, and define how they depend on one another.\n\n### Vars\n\nReactive values that are directly set by code or by user interaction are represented by values of type [`Var<'T>`](/api/v4.1/WebSharper.UI.Var%601). Vars are similar to F# `ref<'T>` in that they store a value of type `'T` that you can get or set using the `Value` property. But they can additionally be reactively observed or two-way bound to HTML input elements.\n\nThe following are available from `WebSharper.UI.Client`:\n\n- [`Doc.Input`](/api/v4.1/WebSharper.UI.Client.Doc#Input) creates an `<input>` element with given attributes that is bound to a `Var<string>`.\n\n      let varText = Var.Create \"initial value\"\n      let myInput = Doc.Input [ attr.name \"my-input\" ] varText\n\n  With the above code, once `myInput` has been inserted in the document, getting `varText.Value` will at any point reflect what the user has entered, and setting it will edit the input.\n\n- [`Doc.IntInput`](/api/v4.1/WebSharper.UI.Client.Doc#IntInput) and [`Doc.FloatInput`](/api/v4.1/WebSharper.UI.Client.Doc#FloatInput) create an `<input type=\"number\">` bound to a `Var<CheckedInput<_>>` of the corresponding type (`int` or `float`). `CheckedInput` provides access to the validity and actual user input, it is defined as follows:\n\n      type CheckedInput<'T> =\n          | Valid of value: 'T * inputText: string\n          | Invalid of inputText: string\n          | Blank of inputText: string\n\n- [`Doc.IntInputUnchecked`](/api/v4.1/WebSharper.UI.Client.Doc#IntInputUnchecked) and [`Doc.FloatInputUnchecked`](/api/v4.1/WebSharper.UI.Client.Doc#FloatInputUnchecked) create an `<input type=\"number\">` bound to a `Var<_>` of the corresponding type (`int` or `float`). They do not check for the validity of the user's input, which can cause wonky interactions. We recommend using `Doc.IntInput` or `Doc.FloatInput` instead.\n- [`Doc.InputArea`](/api/v4.1/WebSharper.UI.Client.Doc#InputArea) creates a `<textarea>` element bound to a `Var<string>`.\n- [`Doc.PasswordBox`](/api/v4.1/WebSharper.UI.Client.Doc#PasswordBox) creates an `<input type=\"password\">` element bound to a `Var<string>`.\n- [`Doc.CheckBox`](/api/v4.1/WebSharper.UI.Client.Doc#CheckBox) creates an `<input type=\"checkbox\">` element bound to a `Var<bool>`.\n- [`Doc.CheckBoxGroup`](/api/v4.1/WebSharper.UI.Client.Doc#CheckBoxGroup) also creates an `<input type=\"checkbox\">`, but instead of associating it with a simple `Var<bool>`, it associates it with a specific `'T` in a `Var<list<'T>>`. If the box is checked, then the element is added to the list, otherwise it is removed.\n\n      type Color = Red | Green | Blue\n\n      // Initially, Green and Blue are checked.\n      let varColor = Var.Create [ Blue; Green ]\n\n      let mySelector =\n          div [] [\n              label [] [\n                  Doc.CheckBoxGroup [] Red varColor\n                  text \" Select Red\"\n              ]\n              label [] [\n                  Doc.CheckBoxGroup [] Green varColor\n                  text \" Select Green\"\n              ]\n              label [] [\n                  Doc.CheckBoxGroup [] Blue varColor\n                  text \" Select Blue\"\n              ]\n          ]\n\n  Result:\n\n      <div>\n        <label><input type=\"checkbox\" /> Select Red</label>\n        <label><input type=\"checkbox\" checked /> Select Green</label>\n        <label><input type=\"checkbox\" checked /> Select Blue</label>\n      </div>\n\n  Plus varColor is bound to contain the list of ticked checkboxes.\n\n- [`Doc.Select`](/api/v4.1/WebSharper.UI.Client.Doc#Select) creates a dropdown `<select>` given a list of values to select from. The label of every `<option>` is determined by the given print function for the associated value.\n\n      type Color = Red | Green | Blue\n\n      // Initially, Green is checked.\n      let varColor = Var.Create Green\n\n      // Choose the text of the dropdown's options.\n      let showColor (c: Color) =\n          sprintf \"%A\" c\n\n      let mySelector =\n          Doc.Select [] showColor [ Red; Green; Blue ] varColor\n\n  Result:\n\n      <select>\n        <option>Red</option>\n        <option>Green</option>\n        <option>Blue</option>\n      </select>\n\n  Plus varColor is bound to contain the selected color.\n\n- [`Doc.Radio`](/api/v4.1/WebSharper.UI.Client.Doc#Radio) creates an `<input type=\"radio\">` given a value, which sets the given `Var` to that value when it is selected.\n\n      type Color = Red | Green | Blue\n\n      // Initially, Green is selected.\n      let varColor = Var.Create Green\n\n      let mySelector =\n          div [] [\n              label [] [\n                  Doc.Radio [] Red varColor\n                  text \" Select Red\"\n              ]\n              label [] [\n                  Doc.Radio [] Green varColor\n                  text \" Select Green\"\n              ]\n              label [] [\n                  Doc.Radio [] Blue varColor\n                  text \" Select Blue\"\n              ]\n          ]\n\n  Result:\n\n      <div>\n        <label><input type=\"radio\" /> Select Red</label>\n        <label><input type=\"radio\" checked /> Select Green</label>\n        <label><input type=\"radio\" /> Select Blue</label>\n      </div>\n\n  Plus varColor is bound to contain the selected color.\n\nMore variants are available in the [`Doc` module](/api/v4.1/WebSharper.UI.Client.Doc).\n\n### Views\n\nThe full power of WebSharper.UI's reactive layer comes with [`View`s](/api/v4.1/WebSharper.UI.View%601). A `View<'T>` is a time-varying value computed from Vars and from other Views. At any point in time the view has a certain value of type `'T`.\n\nOne thing important to note is that the value of a View is not computed unless it is needed. For example, if you use [`View.Map`](#view-map), the function passed to it will only be called if the result is needed. It will only be run while the resulting View is included in the document using [one of these methods](#view-doc). This means that you generally don't have to worry about expensive computations being performed unnecessarily. However it also means that you should avoid relying on side-effects performed in functions like `View.Map`.\n\nIn pseudo-code below, `[[x]]` notation is used to denote the value of the View `x` at every point in time, so that `[[x]]` = `[[y]]` means that the two views `x` and `y` are observationally equivalent.\n\nNote that several of the functions below can be used more concisely using [the V shorthand](#v).\n\n#### Creating and combining Views\n\nThe first and main way to get a View is using the [`View`](/api/v4.1/WebSharper.UI.Var%601#View) property of `Var<'T>`. This retrieves a View that tracks the current value of the Var.\n\nYou can create Views using the following functions and combinators from the `View` module:\n\n- [`View.Const`](/api/v4.1/WebSharper.UI.View#Const%60%601) creates a View whose value is always the same.\n\n      let v = View.Const 42\n\n      // [[v]] = 42\n\n- [`View.ConstAnyc`](/api/v4.1/WebSharper.UI.View#ConstAsync%60%601) is similar to `Const`, but is initialized asynchronously. Until the async returns, the resulting View is uninitialized.\n- [`View.Map`](/api/v4.1/WebSharper.UI.View#Map%60%602) takes an existing View and maps its value through a function.\n\n      let v1 : View<string> = // ...\n      let v2 = View.Map (fun s -> String.length s) v1\n\n      // [[v2]] = String.length [[v1]]\n\n- [`View.Map2`](/api/v4.1/WebSharper.UI.View#Map2%60%603) takes two existing Views and map their value through a function.\n\n      let v1 : View<int> = // ...\n      let v2 : View<int> = // ...\n      let v3 = View.Map2 (fun x y -> x + y) v1 v2\n\n      // [[v3]] = [[v1]] + [[v2]]\n\n  Similarly, [`View.Map3`](/api/v4.1/WebSharper.UI.View#Map3%60%604) takes three existing Views and map their value through a function.\n\n- [`View.MapAsync`](/api/v4.1/WebSharper.UI.View#MapAsync%602) is similar to `View.Map` but maps through an asynchronous function.\n\n  An important property here is that this combinator saves work by abandoning requests. That is, if the input view changes faster than we can asynchronously convert it, the output view will not propagate change until it obtains a valid latest value. In such a system, intermediate results are thus discarded.\n\n  Similarly, [`View.MapAsync2`](/api/v4.1/WebSharper.UI.View#MapAsync2%603) maps two existing Views through an asynchronous function.\n\n- [`View.Apply`](/api/v4.1/WebSharper.UI.View#Apply%602) takes a View of a function and a View of its argument type, and combines them to create a View of its return type.\n\n  While Views of functions may seem like a rare occurrence, they are actually useful together with `View.Const` in a pattern that can lift a function of any number N of arguments into an equivalent of `View.MapN`.\n\n      // This shorthand is defined in WebSharper.UI.Notation.\n      let (<*>) vf vx = View.Apply vf vx\n\n      // Inputs: a function of 4 arguments and 4 Views.\n      let f a b c d = // ...\n      let va = // ...\n      let vb = // ...\n      let vc = // ...\n      let vd = // ...\n\n      // Equivalent to a hypothetical `View.Map4 f va vb vc vd`.\n      let combinedView =\n          View.Const f <*> va <*> vb <*> vc <*> vd\n\n#### Inserting Views in the Doc\n\nOnce you have created a View to represent your dynamic content, here are the various ways to include it in a Doc:\n\n- [`textView`](/api/v4.1/WebSharper.UI.Html#textView) is a reactive counterpart to `text`, which creates a text node from a `View<string>`.\n\n      let varTxt = Var.Create \"\"\n      let vLength =\n          varTxt.View\n          |> View.Map String.length\n          |> View.Map (fun l -> sprintf \"You entered %i characters.\" l)\n      div [] [\n          Doc.Input [] varName\n          textView vLength\n      ]\n\n- [`Doc.BindView`](/api/v4.1/WebSharper.UI.Doc#BindView%60%601) maps a View into a dynamic Doc.\n\n      let varTxt = Var.Create \"\"\n      let vWords =\n          varTxt.View\n          |> View.Map (fun s -> s.Split(' '))\n          |> Doc.BindView (fun words ->\n              words\n              |> Array.map (fun w -> li [] [text w] :> Doc)\n              |> Doc.Concat\n          )\n      div [] [\n          text \"You entered the following words:\"\n          ul [] [ vWords ]\n      ]\n\n- [`Doc.EmbedView`](/api/v4.1/WebSharper.UI.Doc#EmbedView) unwraps a `View<Doc>` into a Doc. It is equivalent to `Doc.BindView id`.\n- `attr.*Dyn` is a reactive equivalent to the corresponding `attr.*`, creating an attribute from a `View<string>`.\n\n  For example, the following sets the background of the input element based on the user input value:\n\n      let varTxt = Var.Create \"\"\n      let vStyle =\n          varTxt.View\n          |> View.Map (fun s -> \"background-color: \" + s)\n      Doc.Input [ attr.styleDyn vStyle ] varTxt\n\n- `attr.*DynPred` is similar to `attr.*Dyn`, but it takes an extra `View<bool>`. When this View is true, the attribute is set (and dynamically updated as with `attr.*Dyn`), and when it is false, the attribute is removed.\n\n      let varTxt = Var.Create \"\"\n      let varCheck = Var.Create true\n      let vStyle =\n          varTxt.View\n          |> View.Map (fun s -> \"background-color: \" + s)\n      div [] [\n          Doc.Input [ attr.styleDynPred vStyle varCheck.View ] varTxt\n          Doc.CheckBox [] varCheck\n      ]\n\n#### Mapping Views on sequences\n\nApplications often deal with varying collections of data. This means using a View of a sequence: a value of type `View<seq<T>>`, `View<list<T>>` or `View<T[]>`. In this situation, it can be sub-optimal to use `Map` or `Doc` to render it: the whole sequence will be re-computed even when a single item has changed.\n\nThe `SeqCached` family of functions fixes this issue. These functions map a View of a sequence to either a new `View<seq<U>>` (functions `View.MapSeqCached*` and method `.MapSeqCached()`) or to a `Doc` (functions `Doc.BindSeqCached` and method `.DocSeqCached()`) but avoid re-mapping items that haven't changed.\n\nThere are different versions of these functions, which differ in how they decide that an item \"hasn't changed\".\n\n- [`View.MapSeqCached : ('T -> 'V) -> View<seq<'T>> -> View<seq<'V>>`](/api/v4.1/WebSharper.UI.View#MapSeqCached) uses standard F# equality to check items.\n\n      let varNums = Var.Create [ 1; 2; 3 ]\n\n      let vStrs =\n          varNums.View\n          |> View.MapSeqCached (fun i ->\n              Console.Log i\n              p [] [ text (string i) ]\n          )\n          |> Doc.BindView Doc.Concat\n          |> Doc.RunAppend JS.Document.Body\n      // Prints 1, 2, 3\n      // Displays 1, 2, 3\n\n      varNums.Value <- [ 1; 2; 3; 4 ]\n      // Prints 4\n      // Displays 1, 2, 3, 4\n      // Note: the existing <p> tags remain, they aren't recreated.\n\n      varNums.Value <- [ 3; 2 ]\n      // Prints nothing\n      // Displays 3, 2\n\n- [`View.MapSeqCachedBy : ('T -> 'K) -> ('T -> 'V) -> View<seq<'T>> -> View<seq<'V>>`](/api/v4.1/WebSharper.UI.View#MapSeqCachedBy) uses the given key function to check items. This means that if an item is added whose key is already present, the corresponding returned item is _not_ changed. So you should only use this when items are intended to be added or removed, but not changed.\n\n      type Person = { Id: int; Name: string: int }\n\n      let ann = { Id = 0; Name = \"Ann\" }\n      let brian = { Id = 1; Name = \"Brian\" }\n      let bobby = { Id = 1; Name = \"Bobby\" }\n      let clara = { Id = 2; Name = \"Clara\" }\n      let dave = { Id = 3; Name = \"Dave\" }\n\n      let varPeople =\n          Var.Create [ ann; brian; clara ]\n\n      varPeople.View\n      |> View.MapSeqCachedBy (fun p -> p.Id) (fun p ->\n          Console.Log p.Id\n          p [] [ text (string p.Name) ]\n      )\n      |> Doc.BindView Doc.Concat\n      |> Doc.RunAppend JS.Document.Body\n      // Prints 1, 2, 3\n      // Displays Ann, Brian, Clara\n\n      varPeople.Value <- [ ann; brian; clara; dave ]\n      // Prints 4\n      // Displays Ann, Brian, Clara, Dave\n      // Note: the existing <p> tags remain, they aren't recreated.\n\n      varPeople.Value <- [ ann; bobby; clara; dave ]\n      // Prints nothing\n      // Displays Ann, Brian, Clara, Dave\n      // The item with Id = 1 is already rendered as Brian,\n      // so it is not re-rendered as Bobby.\n\n- [\\`View.MapSeqCachedViewBy : ('T â†’ 'K) â†’ ('K â†’ View<'T> â†’ 'V) â†’ View<seq<'V>>](/api/v4.1/WebSharper.UI.View#MapSeqCachedViewBy) covers the situation where items are identified by a key function and can be updated. Instead of passing the item's value to the mapping function, it passes a View of it, so you can react to the changes.\n\n      varPeople.View\n      |> View.MapSeqCachedViewBy (fun p -> p.Id) (fun pid vp ->\n          Console.Log pid\n          p [] [ textView (vp |> View.Map (fun p -> string p.Name)) ]\n      )\n      |> Doc.BindView Doc.Concat\n      |> Doc.RunAppend JS.Document.Body\n      // Prints 1, 2, 3\n      // Displays Ann, Brian, Clara\n\n      varPeople.Value <- [ ann; brian; clara; dave ]\n      // Prints 4\n      // Displays Ann, Brian, Clara, Dave\n      // Note: the existing <p> tags remain, they aren't recreated.\n\n      varPeople.Value <- [ ann; bobby; clara; dave ]\n      // Prints nothing\n      // Displays Ann, Bobby, Clara, Dave\n      // The item with Id = 1 is already rendered as Brian,\n      // so its <p> tag remains but its text content changes.\n\nEach of these `View.MapSeqCached*` functions has a corresponding `Doc.BindSeqCached*`:\n\n- [`Doc.BindSeqCached : ('T -> #Doc) -> View<seq<'T>> -> Doc`](/api/v4.1/WebSharper.UI.Client.Doc#BindSeqCached)\n- [`Doc.BindSeqCachedBy : ('T -> 'K) -> ('T -> #Doc) -> View<seq<'T>> -> Doc`](/api/v4.1/WebSharper.UI.Client.Doc#BindSeqCached)\n- [`Doc.BindSeqCachedViewBy : ('T -> 'K) -> ('K -> View<'T> -> #Doc) -> View<seq<'T>> -> Doc`](/api/v4.1/WebSharper.UI.Client.Doc#BindSeqCached)\n\nThese functions map each item of the sequence to a Doc and then concatenates them. They are basically equivalent to passing the result of the corresponding `View.MapSeqCached*` to `Doc.BindView Doc.Concat`, like we did in the examples above.\n\nFinally, all of the above functions are also available as extension methods on the `View<seq<'T>>` type. `.MapSeqCached()` overloads correspond to `View.MapSeqCached*` functions, and `.DocSeqCached()` overloads correspond to `Doc.BindSeqCached*` functions.\n\n### Vars and lensing\n\nThe `Var<'T>` type is actually an abstract class, this makes it possible to create instances with an implementation different from `Var.Create`. The main example of this are **lenses**.\n\nIn WebSharper.UI, a lens is a `Var` without its own storage cell that \"focuses\" on a sub-part of an existing `Var`. For example, given the following:\n\n    type Person = { FirstName : string; LastName : string }\n    let varPerson = Var.Create { FirstName = \"John\"; LastName = \"Doe\" }\n\nYou might want to create a form that allows entering the first and last name separately. For this, you need two `Var<string>`s that directly observe and alter the `FirstName` and `LastName` fields of the value stored in `varPerson`. This is exactly what a lens does.\n\nTo create a lens, you need to pass a getter and a setter function. The getter is called when the lens needs to know its current value, and extracts it from the parent `Var`'s current value. The setter is called when setting the value of the lens; it receives the current value of the parent `Var` and the new value of the lens, and returns the new value of the parent `Var`.\n\n    let varFirstName = varPerson.Lens (fun p -> p.FirstName)\n                                      (fun p n -> { p with FirstName = n })\n    let varLastName = varPerson.Lens (fun p -> p.LastName)\n                                     (fun p n -> { p with LastName = n })\n    let myForm =\n        div [] [\n            Doc.Input [ attr.placeholder \"First Name\" ] varFirstName\n            Doc.Input [ attr.placeholder \"Last Name\" ] varLastName\n        ]\n\n#### Automatic lenses\n\nIn the specific case of records, you can use `LensAuto` to create lenses more concisely. This method only takes the getter, and is able to generate the corresponding setter during compilation.\n\n    let varFirstName = varPerson.LensAuto (fun p -> p.FirstName)\n\n    // The above is equivalent to:\n    let varFirstName = varPerson.Lens (fun p -> p.FirstName)\n                                      (fun p n -> { p with FirstName = n })\n\nYou can be even more concise when using `Doc.Input` and family thanks to [the V shorthand](#v).\n\n### The V Shorthand\n\nMapping reactive values from their model to a value that you want to display can be greatly simplified using the V shorthand. This shorthand revolves around passing calls to the property `view.V` to a number of supporting functions.\n\n#### Views and V\n\nWhen an expression containing a call to `view.V` is passed as argument to one of the supporting functions, it is converted to a call to `View.Map` on this view, and the resulting expression is used in a way relevant to the supporting function.\n\nThe simplest supporting function is called `V`, and it simply returns the view expression.\n\n    type Person = { FirstName: string; LastName: string }\n\n    let vPerson : View<Person> = // ...\n\n    let vFirstName = V(vPerson.V.FirstName)\n\n    // The above is equivalent to:\n    let vFirstName = vPerson |> View.Map (fun p -> p.FirstName)\n\nYou can use arbitrarily complex expressions:\n\n    let vFullName = V(vPerson.V.FirstName + \" \" + vPerson.V.LastName)\n\n    // The above is equivalent to:\n    let vFirstName = vPerson |> View.Map (fun p -> p.FirstName + \" \" + p.LastName)\n\nOther supporting functions use the resulting View in different ways:\n\n- `text` passes the resulting View to `textView`.\n\n      let showName : Doc = text (vPerson.V.FirstName + \" \" + vPerson.V.LastName)\n\n      // The above is equivalent to:\n      let showName =\n          textView (\n              vPerson\n              |> View.Map (fun p -> p.V.FirstName + \" \" + p.V.LastName)\n          )\n\n- `attr.*` attribute creation functions pass the resulting View to the corresponding `attr.*Dyn`.\n\n      type ImgData = { Src: string; Height: int }\n\n      let myImgData = Var.Create { Src = \"/my-img.png\"; Height = 200 }\n\n      let myImg =\n          img [\n              attr.src (myImgData.V.Src)\n              attr.height (string myImgData.V.Height)\n          ] []\n\n      // The above is equivalent to:\n      let myImg =\n          img [\n              attr.srcDyn (myImgData.View |> View.Map (fun i -> i.Src))\n              attr.heightDyn (myImgData.View |> View.Map (fun i -> string i.Height))\n          ] []\n\n- `Attr.Style` passes the resulting View to `Attr.DynamicStyle`.\n\n      type MyStyle = { BgColor: string; Width: int }\n\n      let myStyle = Var.Create { BgColor = \"orangered\"; Width = 400 }\n\n      let myElt =\n          div [\n              Attr.Style \"background-color\" myStyle.V.BgColor\n              Attr.Style \"width\" (sprintf \"%ipx\" myStyle.V.Width)\n          ] [ text \"This is my elt\" ]\n\n      // The above is equivalent to:\n      let myElt =\n          div [\n              Attr.DynamicStyle \"background-color\"\n                  (myStyle |> View.Map (fun s -> s.BgColor))\n              Attr.DynamicStyle \"width\"\n                  (myStyle |> View.Map (fun s -> sprintf \"%ipx\" s.Width))\n          ] [ text \"This is my elt\" ]\n\nCalling `.V` outside of one of the above supporting functions is a compile error. There is one exception: if `view` is a `View<Doc>`, then `view.V` is equivalent to `Doc.EmbedView view`.\n\n    let varPerson = Var.Create (Some { FirstName = \"John\"; LastName = \"Doe\" })\n\n    let vMyDoc = V(\n        match varPerson.V with\n        | None -> Doc.Empty\n        | Some p -> div [] [ text varPerson.V.FirstName ]\n    )\n    let myDoc = vMyDoc.V\n\n    // The above is equivalent to:\n    let vMyDoc =\n        varPerson.View |> View.Map (fun p ->\n            match p with\n            | None -> Doc.Empty\n            | Some p -> div [] [ text p.FirstName ]\n        )\n    let myDoc = Doc.EmbedView vMyDoc\n\n#### Vars and V\n\nVars also have a `.V` property. When used with one of the above supporting functions, it is equivalent to `.View.V`.\n\n    let varPerson = Var.Create { FirstName = \"John\"; LastName = \"Doe\" }\n\n    let vFirstName = V(varPerson.V.FirstName)\n\n    // The above is equivalent to:\n    let vFirstName = V(varPerson.View.V.FirstName)\n\n    // Which is also equivalent to:\n    let vFirstName = varPerson.View |> View.Map (fun p -> p.FirstName)\n\nAdditionally, `var.V` can be used as a shorthand for [lenses](#lens). `.V` is a shorthand for `.LensAuto` when passed to the following supporting functions:\n\n- [`Lens`](/api/v4.1/WebSharper.UI.Client.Doc#Lens) simply creates a lensed Var.\n\n      type Person = { FirstName : string; LastName : string }\n      let varPerson = Var.Create { FirstName = \"John\"; LastName = \"Doe\" }\n\n      let myForm =\n          div [] [\n              Doc.Input [ attr.placeholder \"First Name\" ] (Lens varPerson.V.FirstName)\n              Doc.Input [ attr.placeholder \"Last Name\" ] (Lens varPerson.V.LastName)\n          ]\n\n- [`Doc.InputV`](/api/v4.1/WebSharper.UI.Client.Doc#InputV), [`Doc.InputAreaV`](/api/v4.1/WebSharper.UI.Doc#InputVArea), [`Doc.PasswordBoxV`](/api/v4.1/WebSharper.UI.Doc#PasswordBoxV)\n- [`Doc.IntInputV`](/api/v4.1/WebSharper.UI.Client.Doc#IntInputV), [`Doc.IntInputUncheckedV`](/api/v4.1/WebSharper.UI.Doc#IntInputUncheckedV)\n- [`Doc.FloatInputV`](/api/v4.1/WebSharper.UI.Client.Doc#FloatInputV), [`Doc.FloatInputUncheckedV`](/api/v4.1/WebSharper.UI.Doc#FloatInputUncheckedV)\n\n  type Person = { FirstName : string; LastName : string }\n  let varPerson = Var.Create { FirstName = \"John\"; LastName = \"Doe\" }\n\n  let myForm =\n  div [] [\n  Doc.InputV [ attr.placeholder \"First Name\" ] varPerson.V.FirstName\n  Doc.InputV [ attr.placeholder \"Last Name\" ] varPerson.V.LastName\n  ]\n\n  // The above is equivalent to:\n  let myForm =\n  div [] [\n  Doc.Input [ attr.placeholder \"First Name\" ]\n  (varPerson.LensAuto (fun p -> p.FirstName))\n  Doc.Input [ attr.placeholder \"Last Name\" ]\n  (varPerson.LensAuto (fun p -> p.LastName))\n  ]\n\n  // Which is equivalent to:\n  let myForm =\n  div [] [\n  Doc.Input [ attr.placeholder \"First Name\" ]\n  (varPerson.Lens (fun p -> p.FirstName) (fun p n -> { p with FirstName = n }))\n  Doc.Input [ attr.placeholder \"Last Name\" ]\n  (varPerson.Lens (fun p -> p.LastName) (fun p n -> { p with LastName = n }))\n  ]\n\n### ListModels\n\n[`ListModel<'K, 'T>`](/api/v4.1/WebSharper.UI.ListModel%602) is a convenient type to store an observable collection of items of type `'T`. Items can be accessed using an identifier, or key, of type `'K`.\n\nListModels are to dictionaries as Vars are to refs: a type with similar capabilities, but with the additional capability to be reactively observed, and therefore to have your UI automatically change according to changes in the stored content.\n\n#### Creating ListModels\n\nYou can create ListModels with the following functions:\n\n- [`ListModel.FromSeq`](/api/v4.1/WebSharper.UI.ListModel#FromSeq%60%601) creates a ListModel where items are their own key.\n\n      let myNameColl = ListModel.FromSeq [ \"John\"; \"Ana\" ]\n\n- [`ListModel.Create`](/api/v4.1/WebSharper.UI.ListModel#Create%60%602) creates a ListModel using a given function to determine the key of an item.\n\n      type Person = { Username: string; Name: string }\n\n      let myPeopleColl =\n          ListModel.Create (fun p -> p.Username)\n              [ { Username = \"johnny87\"; Name = \"John\" };\n                { Username = \"theana12\"; Name = \"Ana\" } ]\n\nEvery following example will assume the above `Person` type and `myPeopleColl` model.\n\n#### Modifying ListModels\n\nOnce you have a ListModel, you can modify its contents like so:\n\n- [`listModel.Add`](/api/v4.1/WebSharper.UI.ListModel%602#Add) inserts an item into the model. If there is already an item with the same key, this item is replaced.\n\n      myPeopleColl.Add({ Username = \"mynameissam\"; Name = \"Sam\" })\n      // myPeopleColl now contains John, Ana and Sam.\n\n      myPeopleColl.Add({ Username = \"johnny87\"; Name = \"Johnny\" })\n      // myPeopleColl now contains Johnny, Ana and Sam.\n\n- [`listModel.RemoveByKey`](/api/v4.1/WebSharper.UI.ListModel%602#RemoveByKey) removes the item from the model that has the given key. If there is no such item, then nothing happens.\n\n      myPeopleColl.RemoveByKey(\"theana12\")\n      // myPeopleColl now contains John.\n\n      myPeopleColl.RemoveByKey(\"chloe94\")\n      // myPeopleColl now contains John.\n\n- [`listModel.Remove`](/api/v4.1/WebSharper.UI.ListModel%602#Remove) removes the item from the model that has the same key as the given item. It is effectively equivalent to `listModel.RemoveByKey(getKey x)`, where `getKey` is the key function passed to `ListModel.Create` and `x` is the argument to `Remove`.\n\n      myPeopleColl.Remove({ Username = \"theana12\"; Name = \"Another Ana\" })\n      // myPeopleColl now contains John.\n\n- [`listModel.Set`](/api/v4.1/WebSharper.UI.ListModel%602#Set) sets the entire contents of the model, discarding the previous contents.\n\n      myPeopleColl.Set([ { Username = \"chloe94\"; Name = \"Chloe\" };\n                         { Username = \"a13x\"; Name = \"Alex\" } ])\n      // myPeopleColl now contains Chloe, Alex.\n\n- [`listModel.Clear`](/api/v4.1/WebSharper.UI.ListModel%602#Clear) removes all items from the model.\n\n      myPeopleColl.Clear()\n      // myPeopleColl now contains no items.\n\n- [`listModel.UpdateBy`](/api/v4.1/WebSharper.UI.ListModel%602#UpdateBy) updates the item with the given key. If the function returns None or the item is not found, nothing is done.\n\n      myPeople.UpdateBy (fun u -> Some { u with Name = \"The Real Ana\" }) \"theana12\"\n      // myPeopleColl now contains John, The Real Ana.\n\n      myPeople.UpdateBy (fun u -> None) \"johnny87\"\n      // myPeopleColl now contains John, The Real Ana.\n\n- [`listModel.UpdateAll`](/api/v4.1/WebSharper.UI.ListModel%602#UpdateAll) updates all the items of the model. If the function returns None, the corresponding item is unchanged.\n\n      myPeople.UpdateAll (fun u ->\n          if u.Username.Contains \"ana\" then\n              Some { u with Name = \"The Real Ana\" }\n          else\n              None)\n      // myPeopleColl now contains John, The Real Ana.\n\n- [`listModel.Lens`](/api/v4.1/WebSharper.UI.ListModel%602#Lens) creates an `Var<'T>` that does not have its own separate storage, but is bound to the value for a given key.\n\n      let john : Var<Person> = myPeople.Lens \"johnny87\"\n\n- [`listModel.LensInto`](/api/v4.1/WebSharper.UI.ListModel%602#Lens) creates an `Var<'T>` that does not have its own separate storage, but is bound to a part of the value for a given key. See [lenses](#lens) for more information.\n\n      let varJohnsName : Var<string> =\n          myPeople.LensInto \"johnny87\" (fun p -> p.Name) (fun p n -> { p with Name = n })\n\n      // The following input field edits John's name directly in the listModel.\n      let editJohnsName = Doc.Input [] varJohnsName\n\n#### Reactively observing ListModels\n\nThe main purpose for using a ListModel is to be able to reactively observe it. Here are the ways to do so:\n\n- [`listModel.View`](/api/v4.1/WebSharper.UI.ListModel%602#View) gives a `View<seq<'T>>` that reacts to changes to the model. The following example creates an HTML list of people which is automatically updated based on the contents of the model.\n\n      let myPeopleList =\n          myPeopleColl.View\n          |> Doc.BindView (fun people ->\n              ul [] [\n                  people\n                  |> Seq.map (fun p -> li [] [ text p.Name ] :> Doc)\n                  |> Doc.Concat\n              ] :> Doc\n          )\n\n- [`listModel.ViewState`](/api/v4.1/WebSharper.UI.ListModel%602#ViewState) is equivalent to `View`, except that it returns a `View<ListModelState<'T>>`. Here are the differences:\n\n  - `ViewState` provides better performance.\n  - `ListModelState<'T>` implements `seq<'T>`, but it additionally provides indexing and length of the sequence.\n  - However, a `ViewState` is only valid until the next change to the model.\n\n  As a summary, it is generally better to use `ViewState`. You only need to choose `View` if you need to store the resulting `seq` separately.\n\n- [`listModel.Map`](/api/v4.1/WebSharper.UI.ListModel%5C2#Map%60%601) reactively maps a function on each item. It is similar to [the `View.MapSeqCached` family of functions](#view-seqcached): it is optimized so that the mapping function is not called again on every item when the content changes, but only on changed items. There are two variants:\n\n  - `Map(f: 'T -> 'V)` assumes that the item with a given key does not change. It is equivalent to `View.MapSeqCachedBy` using the ListModel's key function.\n\n        let myDoc =\n            myPeopleColl.Map(fun p ->\n                Console.Log p.Username\n                p [] [ text p.Name ]\n            )\n            |> Doc.BindView Doc.Concat\n            |> Doc.RunAppend JS.Document.Body\n        // Logs johnny87, theana12\n        // Displays John, Ana\n\n        // We add an item with a key that doesn't exist yet,\n        // so the mapping function is called for it and the result is added.\n        myPeopleColl.Add({ Username = \"mynameissam\"; Name = \"Sam\" })\n        // Logs mynameissam\n        // Displays John, Ana, Sam\n\n        // We change the value for an existing key,\n        // so this change is ignored by Map.\n        myPeopleColl.Add({ Username = \"johnny87\"; Name = \"Johnny\" })\n        // Logs nothing, since no key has been added\n        // Displays John, Ana, Sam (unchanged)\n\n  - `Map(f: 'K -> View<'T> -> 'V)` additionally observes changes to individual items that are updated. It is equivalent to `View.MapSeqCachedViewBy` using the ListModel's key function.\n\n        myPeopleColl.Map(fun k vp ->\n            Console.Log k\n            p [] [ text (vp.V.Name) ]\n        )\n        |> Doc.BindView Doc.Concat\n        |> Doc.RunAppend JS.Document.Body\n        // Logs johnny87, theana12\n        // Displays John, Ana\n\n        // We add an item with a key that doesn't exist yet,\n        // so the mapping function is called for it and the result is added.\n        myPeopleColl.Add({ Username = \"mynameissam\"; Name = \"Sam\" })\n        // Logs mynameissam\n        // Displays John, Ana, Sam\n\n        // We change the value for an existing key,\n        // so the mapping function is not called again\n        // but the View's value is updated.\n        myPeopleColl.Add({ Username = \"johnny87\"; Name = \"Johnny\" })\n        // Here we changed the value for an existing key\n        // Logs nothing, since no key has been added\n        // Displays Johnny, Ana, Sam (changed!)\n\n  Note that in both cases, only the current state is kept in memory: if you remove an item and insert it again, the function will be called again.\n\n- [`listModel.MapLens`](/api/v4.1/WebSHarper.UI.ListModel%602#MapLens) is similar to the second `Map` method above, except that it passes an `Var<'T>` instead of a `View<'T>`. This makes it possible to edit list items within the mapping function.\n\n          let myDoc =\n              myPeopleColl.MapLens(fun k vp ->\n                  label [] [\n                      text (vp.V.Username + \": \")\n                      Doc.InputV [] vp.V.Name\n                  ]\n              )\n              |> Doc.BindView Doc.Concat\n\n- [`listModel.Doc`](/api/v4.1/WebSharper.UI.ListModel%602#Doc) is similar to `Map`, but the function must return a `Doc` and the resulting Docs are concatenated. It is similar to [the `Doc.BindSeqCached` family of functions](#view-seqcached).\n- [`listModel.DocLens`](/api/v4.1/WebSharper.UI.ListModel%602#DocLens), similarly, is like `MapLens` but concatenating the resulting Docs.\n- [`listModel.TryFindByKeyAsView`](/api/v4.1/WebSharper.UI.ListModel%602#TryFindByKeyAsView) gives a View on the item that has the given key, or `None` if it is absent.\n\n      let showJohn =\n          myPeopleColl.TryFindByKeyAsView(\"johnny87\")\n          |> Doc.BindView (function\n              | None -> text \"He is not here.\"\n              | Some u -> text (sprintf \"He is here, and his name is %s.\" u.Name)\n          )\n\n- [`listModel.FindByKeyAsView`](/api/v4.1/WebSharper.UI.ListModel%602#FindByKeyAsView) is equivalent to `TryFindByKeyAsView`, except that when there is no item with the given key, an exception is thrown.\n- [`listModel.ContainsKeyAsView`](/api/v4.1/WebSharper.UI.ListModel%602#ContainsKeyAsView) gives a View on whether there is an item with the given key. It is equivalent to (but more optimized than):\n\n      View.Map Option.isSome (listModel.TryFindByKeyAsView(k))"
      },
      {
        "heading": "Routing",
        "content": "If you have a `WebSharper.Sitelets.Router<'T>` value, it can be shared between server and client. A router encapsulates two things: parsing an URL path to an abstract value and writing a value as an URL fragment. So this allows generating links safely on both client When initializing a page client-side, you can decide to install a custom click handler for your page which recognizes some or all local links to handle without browser navigation.\n\n### Install client-side routing\n\nThere are 3 scenarios for client-side routing which WebSharper routing makes possible:\n\n- For creating single-page applications, when browser refresh is never wanted, `Router.Install` creates a global click handler that prevents default behavior of `<a>` links on your page pointing to a local URL.\n- If you want client-side navigation only between some part of the whole site map covered by the router, you can use `Router.Slice` before `Router.Install`. This creates a global click handler that now only override behavior of local links which can be mapped to the subset of endpoints that are handled in the client. For example you can make navigating between `yoursite.com/profile/...` links happen with client-side routing, but any links that would point out of `/profile/...` are still doing browser navigation automatically.\n- If you want to have client-side routing on a sub-page that the server knows nothing about, `Router.InstallHash` subscribes to `window.location.hash` changes only. You can use a router that is specific to that single sub-page.\n\nIn all cases, the `Install` function used returns a `Var`, which you can use to map the visible content of your page from. It has a two way binding to the URL: link or forward/back navigation changes the value of the `Var`, and setting the value does a client-side navigation which also updates the URL automatically.\n\nExample for `Router.Install`, using the router value introduced in the [Sitelets documentation](sitelets):\n\n    let ClientMain() =\n        let location = rPages |> Router.Install Home\n        location.View.Doc(function\n            | Home -> div [] [ text \"This is the home page\" ]\n            | Contact p -> div [] [ text (sprintf \"Contact name:%s, age:%d\" p.Name p.Age) ]\n        )\n\nFirst argument (`Home`) specifies which page value to fall back on if the URL path cannot be parsed (although this won't happen if you set up your server-side correctly), which could be a home or an error page.\n\nAlso, you need to make sure that your router value is `[<JavaScript>]` annotated (or a containing type, module or the assembly is), so that it is available for cross-tier use.\n\n`Router.InstallHash` have the same signature as `Router.Install`, the only difference is that URLs would look like `yoursite.com/#/contact/Bob/32`.\n\nExample for `Router.Slice` and `Router.Install`:\n\n    let ContactMain() =\n        let location =\n            rPages |> Router.Slice\n                (function Contact p -> Some p | _ -> None)\n                Contact\n            |> Router.Install (\"unknown\", 0)\n        location.View.Doc(fun p ->\n            div [] [ text (sprintf \"Contact name:%s, age:%d\" p.Name p.Age) ]\n        )\n\nHere we only install a click handler for the contact pages, which means that a link to root will be a browser navigation, but links between contacts work fully on the client. The first function argument maps a full page value to an option of a value that we handle, and the second function maps this back to a full page value. So instead of a `Var<Pages>` here we get only a `Var<Person>`.\n\nIn a real world application, usually you would have some `View.MapAsync` from the `location` variable, to pull some data related to the subpage from the server by an RPC call, and exposing that as content:\n\n    [<Remote>] // this is a server-side function exposed as a WebSharper RPC\n    let GetContactDetails p = async { ... }\n\n    let ContactMain() =\n        let location = // ...\n        let contactDetails = location.View |> View.MapAsync GetContactDetails\n        contactDetails.Doc(fun p ->\n            // show contact details\n        )"
      },
      {
        "heading": "You can navigate programmatically with `location.Value <- newLoc`, `location |> Var.Set newLoc` or `location := newLoc` (if you have `open WebSharper.UI.Next.Notation`).",
        "content": ""
      }
    ]
  },
  {
    "filename": "websharper_webContext.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/web-context",
        "content": "# Web Context\n\nBoth in Sitelets and Rpc functions, WebSharper provides a value of type `WebSharper.Web.Context` that gives some contextual information about the current request."
      },
      {
        "heading": "Retrieving the context",
        "content": "### Sitelets\n\nIn Sitelets, the context provided by [content-generating functions](sitelets#content) such as `Content.Page` or `Content.Custom` implements `Web.Context`, so you can use it directly.\n\n### Rpc functions\n\nIn Rpc functions, the context can be retrieved using the function `WebSharper.Web.Remoting.GetContext()`. Be careful to only call it from the thread from which your function was called. A typical Rpc has the following structure:\n\n    open WebSharper\n    open WebSharper.Web\n\n    [<Rpc>]\n    let MyRpcFunction () =\n        // Retrieve the context outside of the async {} expression.\n        let context = Remoting.GetContext()\n        async {\n            // Once retrieved, use the context at will here.\n            return System.IO.File.ReadAllText(context.RootFolder + \"/someContent.txt\")\n        }"
      },
      {
        "heading": "User Sessions",
        "content": "The main reason to use the context is to manage user sessions. The member `UserSession` has the following members:\n\n- `LoginUser : username: string * ?persistent: bool -> Async<unit>`\n\n  Logs in the user with the given username. This sets a cookie that is uniquely associated with this username. Set `persistent` to `true` if the user session should last beyond the user's current browser session.\n\n- `LoginUser : username: string * duration: TimeSpan -> Async<unit>`\n\n  Logs in the user with the given username. This sets a cookie that is uniquely associated with this username. The user session should last for the given duration.\n\n- `GetLoggedInUser : unit -> Async<string option>`\n\n  Retrieves the currently logged in user's username, or `None` if the user is not logged in.\n\n- `Logout : unit -> unit`\n\n  Logs the user out.\n\nThe implementation of these functions relies on cookies and thus requires that the browser has enabled cookies."
      },
      {
        "heading": "Other Context functionality",
        "content": "- `ApplicationPath : string` is the virtual application path of the server.\n- `RootFolder : string` is the physical folder on the server machine from which the application is running.\n- `RequestUri : Uri` is the URI of the request.\n- `ResolveUrl : string -> string` resolves URL paths starting with `~` into absolute paths prefixed with the `ApplicationPath`.\n- `Environment : Dictionary<string, obj>` is a host-dependent environment.\n\n  - On ASP.NET Core, this contains the following items:\n\n    - Under key `\"WebSharper.AspNetCore.HttpContext\"`, the HTTP context, of type `Microsoft.AspNetCore.Http.HttpContext`.\n    - Under key `\"WebSharper.AspNetCore.Services\"`, the dependency injection service provider, of type `Microsoft.Extensions.DependencyInjection.IServiceProvider`.\n\n  - On ASP.NET 4.x, this contains the following item:\n\n    - Under key `\"HttpContext\"`, the HTTP context, of type `System.Web.HttpContextBase`.\n\n  - On OWIN, this contains the OWIN environment proper. Additionally, if this is OWIN on ASP.NET 4.x (using Microsoft.Owin.Host.SystemWeb), the above `\"HttpContext\"` key is added to the environment.\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_webWorkers.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/web-workers",
        "content": "# Using Web Workers with WebSharper\n\nWeb Workers are a browser feature that allows running client-side code in parallel. Every worker runs on a separate thread, and they communicate by posting messages to one another.\n\nIn WebSharper 4.4 and later, creating a Web Worker is very simple; much simpler, in fact, than in plain JavaScript."
      },
      {
        "heading": "Creating a Worker",
        "content": "You can call the `WebSharper.JavaScript.Worker` constructor and pass it a function, which will be the entry point for the worker.\n\n    open WebSharper.JavaScript\n\n    let myWorker = new Worker(fun self ->\n        Console.Log \"This was written from the worker!\"\n        self.PostMessage(\"This worker's job is done, it can be terminated.\")\n    )\n    myWorker.Onmessage <- fun event ->\n        Console.Log event.Data\n        myWorker.Terminate()\n\nThe above code will:\n\n- create and start a new Web Worker.\n- print the following from the created worker thread:\n\n      This was written from the worker!\n\n- send the following from the worker thread to the main thread, which then prints it:\n\n      This worker's job is done, it can be terminated.\n\n- terminate the worker thread."
      },
      {
        "heading": "What's happening behind the scenes",
        "content": "A lot of things are happening behind the scenes with this simple call. The WebSharper compiler:\n\n- recognizes that you are calling the `Worker` constructor with a function argument, and sets this function (which we will call the entry point) aside.\n- creates a separate compiled JavaScript file called `MyProject.worker.js` that only contains the entry point and any other functions, classes, etc that it requires. It passes as argument to the entry point the global scope of the worker.\n- compiles the `Worker` constructor call into JavaScript as:\n\n      var myWorker = new Worker(\"MyProject.worker.js\")\n\nIf you have several such `Worker` calls in the same project, subsequent ones will be compiled to JavaScript files called `MyProject.worker0.js`, `MyProject.worker1.js`, and so on."
      },
      {
        "heading": "Message passing",
        "content": "Communication between a Worker and the main thread is done by message passing. The worker can listen for incoming messages from the main thread using `self.Onmessage <- f` or `self.AddEventListener(\"message\", f, false)`, and send messages to the main thread using `self.PostMessage(msg)`. Conversely, the main thread can listen for incoming messages from the worker using `worker.Onmessage <- f` or `self.AddEventListener(\"message\", f, false)`, and send messages to the worker using `worker.PostMessage(msg)`.\n\n    let echoWorker = new Worker(fun self ->\n        // This is the code of the worker\n\n        // Listen to messages from the main thread\n        self.Onmessage <- fun event ->\n\n            // Here we're assuming we'll only ever receive strings\n            let msg = event.Data :?> string\n\n            // Send a message to the main thread\n            self.PostMessage(\"The worker said: \" + msg)\n    )\n\n    // This code is on the main thread\n\n    // Listen to messages from the worker\n    echoWorker.Onmessage <- fun event ->\n\n        // Again we're assuming we'll only ever receive strings\n        let msg = event.Data :?> string\n\n        // Print the received message to the console\n        Console.Log(msg)\n\n    // This will send the string to the worker, receive it back,\n    // and print to the console: \"The worker said: Hello world!\"\n    echoWorker.PostMessage(\"Hello world!\")\n\n    // The worker is still running, we can send more messages\n    // and they will be sent back and forth and printed.\n    echoWorker.PostMessage(\"Hi again!\")"
      },
      {
        "heading": "Using external dependencies",
        "content": "It is possible to use external script dependencies in a Worker. These will be compiled to calls to `importScripts()` in the worker script. For example, here is a worker that uses [math.js](http://mathjs.org/) and the binding [WebSharper.MathJS](https://www.nuget.org/packages/websharper.mathjs) to perform mathematical operations:\n\n    open WebSharper.MathJS\n\n    let myWorker = new Worker(fun self ->\n        self.Onmessage <- fun event ->\n            let msg = event.Data :?> string\n            let res = Math.Derivative(msg, \"x\").ToString()\n            Console.Log(res)\n    )\n    // This will print \"4 * x + 3\":\n    myWorker.PostMessage(\"2x^2 + 3x + 4\")"
      },
      {
        "heading": "Customizing the worker script",
        "content": "There are a few options to customize the generated script for a worker.\n\n- You can customize the filename of the script by passing a string as first argument to the `Worker` constructor:\n\n      // This script will be called \"MyLibrary.worker.js\":\n      let simpleWorker = new Worker(fun self ->\n          Console.Log(\"I'm a worker\")\n      )\n\n      // This script will be called \"MyLibrary.say-hello.js\":\n      let helloWorker = new Worker(\"say-hello\", fun self ->\n          Console.Log(\"I'm called 'say-hello'!\")\n      )\n\n- You can decide to include the values, modules and types marked `[<JavaScriptExport>]` in the generated script by passing an additional `true` argument to the `Worker` constructor. This can be useful for example if you intend to also call the generated script manually from JavaScript.\n\n      [<JavaScriptExport>]\n      let MyExportedFunction() =\n          Console.Log(\"I'm not called directly from the worker entry point\")\n\n      let CreateWorker() =\n          new Worker(\"worker\", true, fun self ->\n              Console.Log(\"This doesn't call MyExportedFunction, but it will be defined anyway\")\n          )\n\nNote that in both cases, you must use a literal string or boolean, rather than a more complex expression, because it must be recognized at compile time."
      },
      {
        "heading": "Customizing the script location",
        "content": "[The behind-the-scenes section](#behind-the-scenes) states that the worker constructor call is translated into the following JavaScript:\n\n    var myWorker = new Worker(\"MyProject.worker.js\")\n\nThat is actually a simplification. In practice, WebSharper needs to figure out the path to the script: the file name is not sufficient. The full path is computed and depends on the type of final project that the code is used in:\n\n- In a client-server `website` project, the default path is `/Scripts/WebSharper/<assemblyname>/<filename>`.\n- In a single-page application (aka `bundle` or `bundleOnly` project), the default path is `/Content/<assemblyname>/<filename>`.\n- In a generated static HTML site (aka `html` project), the default path is `/Scripts/<assemblyname>/<filename>`.\n\nThese correspond to the location where the compiler extracts the files, so in a standard setup, everything just works and there is nothing to do. But if you need it, this is customizable using the `scriptBaseUrl` [configuration setting](project-variables#scriptBaseUrl). It changes the base URL for the script, ie. the paths mentioned aboved minus the `<assemblyname>/<filename>` suffix. Note that this URL **must** end with a slash, and almost always needs to start with a slash too.\n\nHere is an example `wsconfig.json` that deviates from the standard: the output directory into which the files are extracted is customized using `outputDir`, so we need to customize `scriptBaseUrl` too.\n\n    {\n        \"project\": \"bundleOnly\",\n        \"outputDir\": \"wwwroot/js\",\n        \"scriptBaseUrl\": \"/js/\"\n    }\n\n---"
      }
    ]
  },
  {
    "filename": "websharper_wig.md",
    "sections": [
      {
        "heading": "Source: https://developers.websharper.com/docs/v4.x/fs/wig",
        "content": "# WebSharper Interface Generator\n\nThe WebSharper Interface Generator (WIG) is a tool (build task) for generating WebSharper bindings to JavaScript libraries. Bindings allow developers to access these libraries from typed F# code that gets compiled to JavaScript by WebSharper. While it is possible to create bindings manually, WIG allows to write the binding definitions in F#, making full use of the language to streamline repetitive tasks.\n\nSimply put, WIG takes an F# value representing a set of classes, interfaces, and members together with their documentation and mappings to JavaScript, and generates a binding assembly from that definition. The binding is a .NET assembly containing the generated types and method stubs annotated with raw JavaScript code using the `InlineAttribute` custom attribute."
      },
      {
        "heading": "Getting Started",
        "content": "WIG is included with the WebSharper installer. To create a new project select the \"Extension\" template from WebSharper templates. This project file contains the line required for the WIG build task to run.\n\n    <WebSharperProject>InterfaceGenerator</WebSharperProject>\n\nYou get a small example in the `Main.fs` file, which ends in this:\n\n    [<Sealed>]\n    type Extension() =\n        interface IExtension with\n            member ext.Assembly =\n                Definition.Assembly\n\n    [<assembly: Extension(typeof<Extension>)>]\n    do ()\n\nThis exposes the value defined by `Definition.Assembly` to the WIG compiler. The library that you write is used just as a generator for this value, any other code that it has will have no effect on the final assembly produced by the WIG build task."
      },
      {
        "heading": "Constructing Types",
        "content": "Defining classes, interfaces and member signatures requires an abstraction for types. Types are represented as `WebSharper.InterfaceGenerator.Type.IType` values. These values can describe both types from other assemblies (external) or type definitions in current WIG project.\n\n### Immutability and Identity\n\nAdding members or attributes to a type declaration is mutable and returns the type declaration for chaining. However, all operators and helper functions work non-desctructively on member, attribute and resource definitions. This allows mutual recursion between types:\n\n    let A = Class \"A\"\n    let B = Class \"B\"\n\n    A |+> Instance [\n        \"getB\" => T<unit> ^-> B\n    ] |> ignore // \"GetB\" method was addded to method list of A\n\n    B |+> Instance [\n        \"getA\" => T<unit> ^-> A\n    ] |> ignore // \"GetA\" method was addded to method list of B\n\nExample for immutability of members:\n\n    let GetCount = Method \"getCount\" (T<unit> ^-> T<int>)\n    let GetCountObs = GetCount |> Obsolete\n\n    A |+> Instance [ GetCount ]\n    |> ignore // A will have \"GetCount\" without the Obsolete attribute\n\n    B |+> Instance [ GetCountObs ]\n    |> ignore // B will have \"GetCount\" with the Obsolete attribute\n\n### Operator Reference\n\nFunction\n\nOperator\n\nDescription\n\n`Method`\n\n`=>`\n\nDefines a method from name and signature\n\n`Property`\n\n`=@`\n\nDefines a property with a getter and setter\n\n`Getter`\n\n`=?`\n\nDefines a read-only property\n\n`Setter`\n\n`=!`\n\nDefines a write-only property\n\n`?`\n\nDefines a named parameter\n\n`^->`\n\nDefines a function type\n\n`-*`\n\nDefines the type of the `this` parameter on a function\n\n`*+`\n\nDefines the `rest` parameter (ParamArray in .NET)\n\n`Type.ArrayOf`\n\n`!|`\n\nDefines an array type from its element type\n\n`!+`\n\nDefines `arguments` parameter (single ParamArray in .NET)\n\n`!?`\n\nDefines an optional parameter, property or return type\n\n`*`\n\nDefines a tuple type or joins parameters\n\n`+`\n\nDefines an overloaded parameter or a `Choice` property or return type\n\n`|=>`\n\nCopies type definition identifier or applies attributes\n\n`|+>`\n\nAdds members to a type definition\n\n### Side cases\n\n- When defining tuples, `*` expands the tuple if the left hand argument is already a tuple. If you want to define the type `(A * B) * C`, you must use `Type.Tuple [ A * B; C ]`.\n- When defining functions like `A * B ^-> C`, the tuple on the left hand side is automatically converted to a `Type.Parameters` which creates multiple arguments from the tuple elements. If you want to describe a JavaScript function that do take a single 2-length array as argument, you must convert it to a single parameter explicitly: `(A * B).Parameter ^-> C`.\n\n### External Types\n\nExternal types can be defined by using the `T` type function, for example `T<int>`, `<int>`, `T<list<string>>`, `<list<string>>`, `T<MyOtherLibrary.SomeType>`.\n\n### Type Combinators\n\nSimpler types can be combined to form more complex types, including arrays, tuples, function types, and generic instantiations.\n\n    Type.ArrayOf T<int>\n        // array, equivalent to T<int[]>\n        // alternate syntax: !| T<int>\n\n    T<int> * T<float> * T<string>\n        // tuple, equivalent to T<int * float * string>\n        // alternate syntax: Type.Tuple [T<int>; T<float>; T<string>]\n\n    T<int> ^-> T<unit>\n        // function, equivalent to T<int -> unit>\n\n    T<System.Collections.Generic.Dictionary<_,_>>.[T<int>, MyTypeDef]\n        // adding type parameters to a generic type\n        // compile-time error if number of parameters do not match\n\nIn addition, delegate types can be formed. WebSharper treats delegate types specially: their are compiled to JavaScript functions accepting the first argument through the implicit `this` parameter. For example when this can be helpful, consider following JavaScript function:\n\n    function iterate(callback, array) {\n        for (var i = 0; i < array.length; i++) {\n            callback.call(array[i], i);\n        }\n    }\n\nTo bind this function to WebSharper one needs to provide a type for the `callback` parameter, which is a function called with an element of the array passed through the `this` implicit parameter and the array index passed through the first parameter. This can be achieved thus:\n\n    let callbackType = T<obj> -* T<int> ^-> T<unit>\n    let iterateType  = callbackType * Type.ArrayOf T<obj> ^-> T<unit>\n\nThe type of the callback is then compiled to a delegate type in F#, `Func<obj,int,unit>`.\n\n### Self Placeholder\n\nThe `TSelf` type value will be evaluated to the type the defined member is added to. This allows creating a member, list of members or `ClassMembers` value (list of members marked with `Instance` or `Static`) and reuse it by adding it to multiple type declarations."
      },
      {
        "heading": "Defining Members",
        "content": "The primary use of type values is the definition of member signatures, methods, constructors, properties and fields.\n\n### Methods\n\nMethod representations are constructed using the `Method` (short form: `=>`) combinator that takes the name of the method and the corresponding functional type. Some examples:\n\n    let methods =\n        [\n            Method \"dispose\" T<unit -> unit>\n            Method \"increment\" (T<int> ^-> T<int>)\n            \"add\" => T<int> * T<int> ^-> T<int>\n        ]\n\nVoid return types and empty parameter lists are indicated by the `unit` type, multiple parameters are indicated by tuple types. It is an error to define a method with a non-functional type.\n\n### Parameter Names\n\nBy default, method parameters get autogenerated names. You can customize parameter names as follows:\n\n    let methods =\n        [\n            Method \"dispose\" (T<unit>?object ^-> T<unit>)\n            Method \"increment\" (T<int>?value ^-> T<int>)\n            \"add\" => T<int>?x * T<int>?y ^-> T<int>\n        ]\n\n### Variable-Argument Signatures\n\nF# supports variable-argument methods via the `System.ParamArrayAttribute` annotation. WebSharper understands this annotation and compiles such methods and delegates to variable-argument accepting functions in JavaScript. Here is the syntax to define a variable-argument signature:\n\n    let methods =\n        [\n            \"t1\" => !+ T<obj> ^-> T<unit>\n            \"t2\" => T<string> *+ T<obj> ^-> T<unit>\n        ]\n\nWhen compiled to F#, these methods will have the following signatures:\n\n    val t1 : ([<System.ParamArray>] args: obj []) -> unit\n    val t2 : string * ([<System.ParamArray>] args: obj []) -> unit\n\n### Optional Parameters\n\nParameters can be made optional:\n\n    Method \"exit\" (!? T<string>?reason ^-> T<unit>)\n\nSignatures such as the one above generate multiple members by implicit overloading (see below).\n\n### Implicit Overloads\n\nType unions facilitate describing JavaScript methods that accept arguments of either-or types. Type unions are implemented by implicit overloading of generated members. For example:\n\n    \"add\" => (T<int> + T<string>) * (T<obj> + T<string>) ^-> T<unit>\n\nThis method can accept either `string` or an `int` as the first argument, and either an `obj` value or a `string` as the second. Four overloads are generated for this signature.\n\n### Properties\n\nProperties can be generated with a getter, a setter or both. Below are the full and abbreviated syntax forms:\n\n    let properties =\n        [\n            Getter \"ReadOnly\" T<int>\n            Setter \"WriteOnly\" T<int>\n            Property \"Mutable\" T<int>\n        ]\n\n    let shorthand =\n        [\n            \"ReadOnly\"  =? T<int>\n            \"WriteOnly\" =! T<int>\n            \"Mutable\"   =@ T<int>\n        ]\n\n#### Indexed properties\n\nProperties can have indexers. `\"\" =@ T<string> |> Indexed T<int>` creates an indexed property where `x.[n] : string` translates to `x[n]`. If the property name is not empty: `\"Lines\" =@ T<string> |> Indexed T<int>` creates an indexed property where `x.Lines.[n]` translates to `x.Lines[n]`.\n\nIf you define a custom inline, use `$index` to refer to the index parameter.\n\n### Constructors\n\nConstructors definitions are similar to methods but do not carry a return type. Examples:\n\n    let constructors =\n        [\n            Constructor T<unit>\n            Constructor (T<int>?width * T<int>?height)\n        ]\n\n#### JavaScript Object Expression\n\n`ObjectConstructor (T<int>?x * T<int>?y)` defines a .NET constructor with JavaScript inline `{ x = $x, y = $y }`.\n\n### Interfaces\n\nInterfaces are defined using the `Interface` keyword and then extended with members.\n\n    Interface \"IAccessible\"\n\n### Member Definitions\n\nMember definitions are appended using the `|+>` combinator, for example:\n\n    Interface \"IAccessible\"\n    |+> [\n        \"Access\" => T<unit->unit>\n        \"LastAccessTime\" =? T<System.DateTime>\n    ]\n\nInterface definitions take a `list<CodeModel.IInterfaceMember>`. Class definitions take a `CodeModel.ClassMembers` value, which can be constructed from a `list<CodeModel.IClassMember>` using the `Instance` and `Static` functions.\n\n### Inheritance\n\nInterfaces can inherit or extend multiple other interfaces. The syntax is as follows:\n\n    Interface \"IAccessible\"\n    |=> Extends [T<System.IComparable>; T<System.IEnumerable<int>>]\n    |+> [\n        \"Access\"         => T<unit->unit>\n        \"LastAccessTime\" =? T<System.DateTime>\n    ]\n\n### Classes\n\nClass definition is very similar to interface definition. It starts with the `Class` keyword:\n\n    let Pear =\n        Class \"Pear\"\n        |+> Static [\n            \"Create\" => T<unit> ^-> TSelf\n        ]\n        |+> Instance [\n            \"Eat\"     => T<unit->unit>\n            \"IsEaten\" =? T<bool>\n        ]\n\n### Class Inheritance\n\nThe syntax for class inheritance is as follows:\n\n    Class \"ChildClass\"\n    |=> Inherits BaseClass\n\n### Interface Implementation\n\nThe syntax for interface implementation is as follows:\n\n    Class \"MyClass\"\n    |=> Implements [T<System.IComparable>]\n\n### Nested Classes\n\nClass nesting is allowed:\n\n    Class \"MyClass\"\n    |=> Nested [\n        Class \"SubClass\"\n    ]\n\n### Generics\n\n#### Generic Types\n\nGeneric types and interfaces are defined by prefixing the definition with the code of the form `Generic --- fun t1 t2 t3 ->`. The `t1..t3` parameters can be used as types in the definition and represent the generic parameters. The length of the operator should be equal to the number of parameters (up to 4).\n\nFor example:\n\n    Generic -- fun t1 t2 ->\n        Interface \"IDictionary\"\n        |+> [\n            \"Lookup\"      => t1 ^-> t2\n            \"ContainsKey\" => t1 ^-> T<bool>\n            \"Add\"         => t1 * t2 ^-> T<unit>\n            \"Remove\"      => t1 ^-> T<unit>\n        ]\n\nThis compiles to the following signature:\n\n    type IDictionary<'T1,'T2> =\n        abstract member Lookup : 'T1 -> 'T2\n        abstract member ContainsKey : 'T1 -> bool\n        abstract member Add : 'T1 * 'T2 -> unit\n        abstract member Remove : 'T1 -> unit\n\nThis syntax can produce up to 4 type parameters. To have more, the `Generic -` helper can be nested, or use `GenericN n - fun [t1; t2; .. tN] ->`. Although this gives an incomplete pattern match warning, there will be no runtime errors if the matching the list for the provided length `n`.\n\n#### Generic Methods\n\nSimilarly, generic methods are generated using lambda expressions, for example:\n\n    Generic - fun t ->\n        \"length\" => T<list<_>>.[t] ^-> T<int>\n\nThis code would generate the following F# signature:\n\n    val Length<'T> : list<'T> -> int\n\nYou can use `Generic %` to add the same generics to a list of members, `Generic *` to add the same generics to a `ClassMembers` value. Also `Generic + [\"a\"; \"b\"; ...] --- ...` specifies the names of the type parameters.\n\n#### Type Constraints\n\nYou can now set type constraints on parameters using `p.Constraints <- [...]` inside the lambda passed to `Generic -`. Previous `WithConstraints` helper is removed as we want to have all helper functions named `With...` to be non-destructive."
      },
      {
        "heading": "Modifiers",
        "content": "### Documentation Comments\n\nDocumentation comments can be added using the `WithComment` function."
      },
      {
        "heading": "Customizing JavaScript",
        "content": "By default, inline JavaScript definitions are inferred for all methods and properties from their names. This is intuitive and convenient but not fully general. Therefore it is possible to bypass the inferred inlines and customize the generated bindings.\n\n### Default Inline Generation\n\nDefault bindings are name-based. For example, a static function called `foo` with three arguments on a class called `Bar`, produces the JavaScript inline `Bar.foo($0,$1,$2)`.\n\nGenerated .NET names are automatically capitalized, so that this function is accessible as `Bar.Foo` from F#.\n\nQualified names can be used on classes that are accessible in JavaScript with a qualified name, for example:\n\n    Class \"geometry.Point\"\n\nThis generates a .NET class `Point` which binds all static members as `geometry.Point.foo()` in JavaScript.\n\n### Inline Transformations\n\n#### Functions\n\nThe `FSharpFunc<'TArg, 'TRes>` type (which is used for lambdas by the F# compiler) always take one parameter (which can be a tuple). In WebSharper translation, these become JavaScript functions taking a single fixed-length array (although curried functions only used in local scope are optimized). However, it is often required that we pass functions defined in F# to a JavaScript library (for example event handlers, callbacks, functional-style libraries). WIG automatically converts between these function calling conventions.\n\n#### Erased unions\n\nUnion types (for example `T<int> + T<string>`) can create method overloads, but also `Union` typed properties or method return types when the cases can be distinguished in JavaScript using the `typeof`, `Array.isArray` and the `arr.length` functions. In F# this means either at most one array case or possibly multiple tuple cases with all different length, at most one number type (including `DateTime` and `TimeSpan`, which are proxied as a Number), `string`, `bool`, and at most one other object type. If there are cases which can't be separated, the type will default to `obj`.\n\n#### Option\n\nBy using the `!?` operator on the type of a property, it will be an option type in F# which is converted to and from an existing or missing field on a JavaScript object. On method returns, undefined is converted to `None`, all other values (including `null`) to `Some ...`.\n\n#### Custom Inline Transformations\n\nYou can add a custom defined inline transformation with the `WithInterop` helper. This takes a record with an `In` and an `Out` field, both `string -> string`. For example:\n\n    let Index =\n        T<int> |> WithInterop {\n            In  = fun s -> s + \" - 1\"\n            Out = fun s -> s + \" + 1\"\n        }\n\nUse this `Type.Type` value instead of `T<int>` in your member declarations where you want to handle an index as 1-based in your code, but pass it to and get it from a 0-based value in a JavaScript library. On method parameters and property setters the `In` function will be used on the parameter or property value in the automatic inline. On method return values and property getters the `Out` function will be used on the whole inline of the method or property getter.\n\n#### Erasing Inline Transformations\n\nUse the `WithNoInterop` helper to clean any automatic and custom inline transformations from a `Type.Type` value.\n\n### Customizations\n\n#### Custom Names\n\nThe simplest form of customization allows to decouple the .NET name of a member from the name used by the inline generation process. This is done by the `WithSourceName` function. For example:\n\n    \"ClonePoint\" => Point ^-> Point\n    |> WithSourceName \"clone\"\n\nThis generates a method that is available as `ClonePoint` from .NET but calls `clone` in JavaScript.\n\n#### Custom Inline Methods\n\nThe method and constructor inlines can be set explicitly by using `WithInline`.\n\n#### Custom Inline Properties\n\nProperties have separate inlines for the getter and the setter methods. These can be set explicitly by using `WithGetterInline` and `WithSetterInline` respectively.\n\n#### Custom Inlines Using Transformations\n\nTo define a custom inline for a method that still makes use of the default or custom inline transformations on parameters and return value, use the `WithInteropInline` helper. It takes a function typed `(string -> string) -> string`, use the provided function on a parameter name or index to get its transformed inline. For example, defining an `on` event setter with function argument detupling:\n\n    \"onChange\" => (T<int> * T<obj> ^-> T<unit>)?callback ^-> T<unit>\n    |> WithInteropInline (fun tr -> \"$this.on('change', \" + tr \"callback\" + \")\"\n\nSimilar helpers exists for property getters and setters: `WithInteropGetterInline` and `WithInteropSetterInline`. For getters, provided function is only usable for transforming `\"index\"` in the case of an indexed property, and for setters transforming `\"value\"` or `\"index\"`.\n\n#### Obsoleted Members and Types\n\nUse the `Obsolate` helper to mark a type or member definition with `System.ObsoleteAttribute`. `ObsolateWithMessage` also sets a custom warning message."
      },
      {
        "heading": "Best Practices",
        "content": "The benefit of using F# for generating the bindings is that repetitive tasks or patterns can be distributed as functions. Several such patterns are pre-defined in the standard library.\n\n### Configuration Class Patterns\n\nThese patterns for constructing member lists are useful for describing JavaScript configuarion objects. Configuration objects typically are simple collections of fields, most of them optional, that are used to describe how another object it to be constructed or operate. Let us take a simple example:\n\n    let MyConfig : Class =\n        Class \"classname\"\n        |+> Pattern.RequiredFields [\n                \"name\", T<string>\n            ]\n        |+> Pattern.OptionalFields [\n                \"width\", T<int>\n                \"height\", T<int>\n            ]\n\nThis definition would produce a class useable from F# that would compile to simple JavaScript object literals:\n\n    MyConfig(\"Alpha\", Width=140)\n\nThe `Width` property is write-only, but there is also a `WidthOpt` property generated which allow access to the optional field typed as an F# `option` value.\n\n`Pattern.ObsoleteFields` can be used similarly, to create a list of properties with the `Obsolete` attribute.\n\n### Enumeration Patterns\n\nJavaScript functions often accept only a fixed set of constants, such as strings. Typing such parameters with `string` would be misleading to the user. The enumeration pattern allows to generate a type that is limited to a specific set of constants, specified as either inlines or strings literals. See `Pattern.EnumInlines` and `Pattern.EnumStrings`, both of which generate `Class` values."
      },
      {
        "heading": "Assembly and Namespaces",
        "content": "You have to provide the WIG compiler with a single `CodeModel.Assembly` value as described in the \"Getting Started\" section. Construct this with the `Assembly` helper which takes a list of `CodeModel.Namespace` values which can be created with the `Namespace` helper specifying its name and a list of `CodeModel.NamespaceEntity` values. These latter can be type definitions or resource types.\n\n### Missing Type Definitions\n\nIf you have a type definition which you refer to but does not get included in a namespace in the assembly definition, when building the library, you will get an error."
      },
      {
        "heading": "Resources",
        "content": "You can define WebSharper resource classes using the `Resource` function. Pass it to `AssemblyWide` to make the resource loaded if anything from the currently created assembly is used.\n\n    Namespace \"WebSharper.JQuery.Resources\" [\n        Resource \"JQuery\" \"http://code.jquery.com/jquery-1.11.2.min.js\"\n        |> AssemblyWide\n    ]"
      },
      {
        "heading": "Use the `Requires` helper to add a list of defined resources as a dependency to a type definition or another resource definition. Use the `RequiresExternal` to add a list of resource classes from another assembly to a type definition or a resource definition.",
        "content": ""
      }
    ]
  }
]